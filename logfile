
chdir(/usr/share/vim)
fchdir() to previous dir
sourcing "$VIM/vimrc"
line 1: " All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by
Executing: " All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by
line 2: " the call to :runtime you can find below.  If you wish to change any of those
Executing: " the call to :runtime you can find below.  If you wish to change any of those
line 3: " settings, you should do it in this file (/etc/vim/vimrc), since debian.vim
Executing: " settings, you should do it in this file (/etc/vim/vimrc), since debian.vim
line 4: " will be overwritten everytime an upgrade of the vim packages is performed.
Executing: " will be overwritten everytime an upgrade of the vim packages is performed.
line 5: " It is recommended to make changes after sourcing debian.vim since it alters
Executing: " It is recommended to make changes after sourcing debian.vim since it alters
line 6: " the value of the 'compatible' option.
Executing: " the value of the 'compatible' option.
line 7: 
Executing: 
line 8: runtime! debian.vim
Executing: runtime! debian.vim
Searching for "debian.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/debian.vim"
Searching for "/var/lib/vim/addons/debian.vim"
Searching for "/etc/vim/debian.vim"
Searching for "/usr/share/vim/vimfiles/debian.vim"
Searching for "/usr/share/vim/vim81/debian.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 8: sourcing "/usr/share/vim/vim81/debian.vim"
line 1: " Normally we use vim-extensions. If you want true vi-compatibility
Executing: " Normally we use vim-extensions. If you want true vi-compatibility
line 2: " remove change the following statements
Executing: " remove change the following statements
line 3: set nocompatible^I" Use Vim defaults instead of 100% vi compatibility
Executing: set nocompatible^I" Use Vim defaults instead of 100% vi compatibility
line 4: set backspace=indent,eol,start^I" more powerful backspacing
Executing: set backspace=indent,eol,start^I" more powerful backspacing
line 5: 
Executing: 
line 6: " Now we set some defaults for the editor
Executing: " Now we set some defaults for the editor
line 7: set history=50^I^I" keep 50 lines of command line history
Executing: set history=50^I^I" keep 50 lines of command line history
line 8: set ruler^I^I" show the cursor position all the time
Executing: set ruler^I^I" show the cursor position all the time
line 9: 
Executing: 
line 10: " modelines have historically been a source of security/resource
Executing: " modelines have historically been a source of security/resource
line 11: " vulnerabilities -- disable by default, even when 'nocompatible' is set
Executing: " vulnerabilities -- disable by default, even when 'nocompatible' is set
line 12: set nomodeline
Executing: set nomodeline
line 13: 
Executing: 
line 14: " Suffixes that get lower priority when doing tab completion for filenames.
Executing: " Suffixes that get lower priority when doing tab completion for filenames.
line 15: " These are files we are not likely to want to edit or read.
Executing: " These are files we are not likely to want to edit or read.
line 16: set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
Executing: set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
line 17: 
Executing: 
line 18: " We know xterm-debian is a color terminal
Executing: " We know xterm-debian is a color terminal
line 19: if &term =~ "xterm-debian" || &term =~ "xterm-xfree86"
Executing: if &term =~ "xterm-debian" || &term =~ "xterm-xfree86"
line 20:   set t_Co=16
Executing:   set t_Co=16
line 21:   set t_Sf=^[[3%dm
Executing:   set t_Sf=^[[3%dm
line 22:   set t_Sb=^[[4%dm
Executing:   set t_Sb=^[[4%dm
line 23: endif
Executing: endif
line 24: 
Executing: 
line 25: " Some Debian-specific things
Executing: " Some Debian-specific things
line 26: if has('gui')
Executing: if has('gui')
line 27:   " Must define this within the :if so it does not cause problems with
Executing:   " Must define this within the :if so it does not cause problems with
line 28:   " vim-tiny (which does not have +eval)
Executing:   " vim-tiny (which does not have +eval)
line 29:   function! <SID>MapExists(name, modes)
Executing:   function! <SID>MapExists(name, modes)
line 37: 
Executing: 
line 38:   " Make shift-insert work like in Xterm
Executing:   " Make shift-insert work like in Xterm
line 39:   autocmd GUIEnter * if !<SID>MapExists("<S-Insert>", "nvso") | execute "map <S-Insert> <MiddleMouse>" | endif
Executing:   autocmd GUIEnter * if !<SID>MapExists("<S-Insert>", "nvso") | execute "map <S-Insert> <MiddleMouse>" | endif
line 40:   autocmd GUIEnter * if !<SID>MapExists("<S-Insert>", "ic") | execute "map! <S-Insert> <MiddleMouse>" | endif
Executing:   autocmd GUIEnter * if !<SID>MapExists("<S-Insert>", "ic") | execute "map! <S-Insert> <MiddleMouse>" | endif
line 41: endif
Executing: endif
line 42: 
Executing: 
line 43: " Set paper size from /etc/papersize if available (Debian-specific)
Executing: " Set paper size from /etc/papersize if available (Debian-specific)
line 44: if filereadable("/etc/papersize")
Executing: if filereadable("/etc/papersize")
line 45:   let s:papersize = matchstr(readfile('/etc/papersize', '', 1), '\p*')
Executing:   let s:papersize = matchstr(readfile('/etc/papersize', '', 1), '\p*')
line 46:   if strlen(s:papersize)
Executing:   if strlen(s:papersize)
line 47:     exe "set printoptions+=paper:" . s:papersize
Executing:     exe "set printoptions+=paper:" . s:papersize
line 48:   endif
Executing:   endif
line 49: endif
Executing: endif
line 50: 
Executing: 
finished sourcing /usr/share/vim/vim81/debian.vim
continuing in /usr/share/vim/vimrc
Searching for "/usr/share/vim/vimfiles/after/debian.vim"
Searching for "/etc/vim/after/debian.vim"
Searching for "/var/lib/vim/addons/after/debian.vim"
Searching for "/home/kangaroo/.vim/after/debian.vim"
line 9: 
Executing: 
line 10: if has("syntax")
Executing: if has("syntax")
line 11:   syntax on
Executing:   syntax on
line 11: so $VIMRUNTIME/syntax/syntax.vim
Executing: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 11: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
Executing: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
Executing: " Last Change:^I2001 Sep 04
line 4: 
Executing: 
line 5: " This file is used for ":syntax on".
Executing: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
Executing: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
Executing: 
line 8: if !has("syntax")
Executing: if !has("syntax")
line 9:   finish
Executing:   finish
line 10: endif
Executing: endif
line 11: 
Executing: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
Executing: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
Executing: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
Executing: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
Executing:   so <sfile>:p:h/nosyntax.vim
line 16: endif
Executing: endif
line 17: 
Executing: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
Executing: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Executing: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/syntax/synload.vim"
Searching for "/var/lib/vim/addons/syntax/synload.vim"
Searching for "/etc/vim/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
Executing: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
Executing: " Last Change:^I2016 Nov 04
line 4: 
Executing: 
line 5: " This file sets up for syntax highlighting.
Executing: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
Executing: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
Executing: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
Executing: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
Executing: 
line 10: if !has("syntax")
Executing: if !has("syntax")
line 11:   finish
Executing:   finish
line 12: endif
Executing: endif
line 13: 
Executing: 
line 14: " let others know that syntax has been switched on
Executing: " let others know that syntax has been switched on
line 15: let syntax_on = 1
Executing: let syntax_on = 1
line 16: 
Executing: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
Executing: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
Executing: if exists("colors_name")
line 19:   exe "colors " . colors_name
Executing:   exe "colors " . colors_name
line 20: else
Executing: else
line 21:   runtime! syntax/syncolor.vim
Executing:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/etc/vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
Executing: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
Executing: " Last Change:^I2001 Sep 12
line 4: 
Executing: 
line 5: " This file sets up the default methods for highlighting.
Executing: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
Executing: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
Executing: " Also used from init_highlight().
line 8: 
Executing: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
Executing: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
Executing:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
Executing:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
Executing:   command -nargs=* SynLink hi link <args>
line 13: else
Executing: else
line 14:   if syntax_cmd == "enable"
Executing:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
Executing:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
Executing:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
Executing:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
Executing:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
Executing:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
Executing:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
Executing:     command -nargs=* SynLink hi! link <args>
line 22:   else
Executing:   else
line 23:     " User defined syncolor file has already set the colors.
Executing:     " User defined syncolor file has already set the colors.
line 24:     finish
Executing:     finish
line 25:   endif
Executing:   endif
line 26: endif
Executing: endif
line 27: 
Executing: 
line 28: " Many terminals can only use six different colors (plus black and white).
Executing: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
Executing: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
Executing: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
Executing: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
Executing: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
Executing: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
Executing:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
Executing:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
Executing:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
Executing:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
Executing:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
Executing:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
Executing:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
Executing:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
Executing:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
Executing: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
Executing:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
Executing: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
Executing:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
Executing: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
Executing:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
Executing: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
Executing:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
Executing: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
Executing:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
Executing: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
Executing:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
Executing: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
Executing:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
Executing: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
Executing:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
Executing: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
Executing:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
Executing: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
Executing: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
Executing: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
Executing: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
Executing: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
Executing: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
Executing: 
line 57: " Common groups that link to default highlighting.
Executing: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
Executing: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
Executing: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
Executing: hi link String^I^IConstant
line 60: SynLink Character^IConstant
Executing: SynLink Character^IConstant
line 60: hi link Character^IConstant
Executing: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
Executing: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
Executing: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
Executing: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
Executing: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
Executing: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
Executing: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
Executing: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
Executing: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
Executing: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
Executing: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
Executing: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
Executing: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
Executing: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
Executing: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
Executing: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
Executing: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
Executing: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
Executing: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
Executing: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
Executing: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
Executing: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
Executing: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
Executing: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
Executing: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
Executing: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
Executing: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
Executing: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
Executing: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
Executing: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
Executing: hi link StorageClass^IType
line 76: SynLink Structure^IType
Executing: SynLink Structure^IType
line 76: hi link Structure^IType
Executing: hi link Structure^IType
line 77: SynLink Typedef^I^IType
Executing: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
Executing: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
Executing: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
Executing: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
Executing: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
Executing: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
Executing: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
Executing: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
Executing: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
Executing: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
Executing: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
Executing: hi link Debug^I^ISpecial
line 83: 
Executing: 
line 84: delcommand SynColor
Executing: delcommand SynColor
line 85: delcommand SynLink
Executing: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/etc/vim/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/kangaroo/.vim/after/syntax/syncolor.vim"
line 22: endif
Executing: endif
line 23: 
Executing: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
Executing: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
Executing: let s:cpo_save = &cpo
line 26: set cpo&vim
Executing: set cpo&vim
line 27: 
Executing: 
line 28: " First remove all old syntax autocommands.
Executing: " First remove all old syntax autocommands.
line 29: au! Syntax
Executing: au! Syntax
line 30: 
Executing: 
line 31: au Syntax *^I^Icall s:SynSet()
Executing: au Syntax *^I^Icall s:SynSet()
line 32: 
Executing: 
line 33: fun! s:SynSet()
Executing: fun! s:SynSet()
line 61: 
Executing: 
line 62: 
Executing: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
Executing: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 64: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
Executing: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
Executing: 
line 70: 
Executing: 
line 71: " Source the user-specified syntax highlighting file
Executing: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
Executing: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
Executing:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
Executing:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
Executing:     execute "source " . fnameescape(s:fname)
line 76:   endif
Executing:   endif
line 77: endif
Executing: endif
line 78: 
Executing: 
line 79: " Restore 'cpoptions'
Executing: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
Executing: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
Executing: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
Executing: 
line 21: " Load the FileType autocommands if not done yet.
Executing: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
Executing: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
Executing:   let s:did_ft = 1
line 24: else
Executing: else
line 25:   filetype on
Executing:   filetype on
Searching for "filetype.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/etc/vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 25: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
Executing: " Vim support file to detect file types
line 2: "
Executing: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2019 Nov 01
Executing: " Last Change:^I2019 Nov 01
line 5: 
Executing: 
line 6: " Listen very carefully, I will say this only once
Executing: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
Executing: if exists("did_load_filetypes")
line 8:   finish
Executing:   finish
line 9: endif
Executing: endif
line 10: let did_load_filetypes = 1
Executing: let did_load_filetypes = 1
line 11: 
Executing: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
Executing: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
Executing: let s:cpo_save = &cpo
line 14: set cpo&vim
Executing: set cpo&vim
line 15: 
Executing: 
line 16: augroup filetypedetect
Executing: augroup filetypedetect
line 17: 
Executing: 
line 18: " Ignored extensions
Executing: " Ignored extensions
line 19: if exists("*fnameescape")
Executing: if exists("*fnameescape")
line 20: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
Executing: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 22: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
Executing: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 29: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
Executing: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
Executing: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
Executing:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
Executing: endif
line 36: 
Executing: 
line 37: " Pattern used to match file names which should not be inspected.
Executing: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
Executing: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
Executing: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
Executing:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
Executing: endif
line 42: 
Executing: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
Executing: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
Executing: " file name matches ft_ignore_pat.
line 45: " When using this, the entry should probably be further down below with the
Executing: " When using this, the entry should probably be further down below with the
line 46: " other StarSetf() calls.
Executing: " other StarSetf() calls.
line 47: func! s:StarSetf(ft)
Executing: func! s:StarSetf(ft)
line 52: 
Executing: 
line 53: " Vim help file
Executing: " Vim help file
line 54: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
Executing: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 55: 
Executing: 
line 56: " Abaqus or Trasys
Executing: " Abaqus or Trasys
line 57: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
Executing: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 58: 
Executing: 
line 59: " 8th (Firth-derivative)
Executing: " 8th (Firth-derivative)
line 60: au BufNewFile,BufRead *.8th^I^I^Isetf 8th
Executing: au BufNewFile,BufRead *.8th^I^I^Isetf 8th
line 61: 
Executing: 
line 62: " A-A-P recipe
Executing: " A-A-P recipe
line 63: au BufNewFile,BufRead *.aap^I^I^Isetf aap
Executing: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 64: 
Executing: 
line 65: " A2ps printing utility
Executing: " A2ps printing utility
line 66: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
Executing: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 67: 
Executing: 
line 68: " ABAB/4
Executing: " ABAB/4
line 69: au BufNewFile,BufRead *.abap^I^I^Isetf abap
Executing: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 70: 
Executing: 
line 71: " ABC music notation
Executing: " ABC music notation
line 72: au BufNewFile,BufRead *.abc^I^I^Isetf abc
Executing: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 73: 
Executing: 
line 74: " ABEL
Executing: " ABEL
line 75: au BufNewFile,BufRead *.abl^I^I^Isetf abel
Executing: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 76: 
Executing: 
line 77: " AceDB
Executing: " AceDB
line 78: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
Executing: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 79: 
Executing: 
line 80: " Ada (83, 9X, 95)
Executing: " Ada (83, 9X, 95)
line 81: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
Executing: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 82: if has("vms")
Executing: if has("vms")
line 83:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
Executing:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 84: else
Executing: else
line 85:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
Executing:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 86: endif
Executing: endif
line 87: 
Executing: 
line 88: " AHDL
Executing: " AHDL
line 89: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
Executing: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 90: 
Executing: 
line 91: " AMPL
Executing: " AMPL
line 92: au BufNewFile,BufRead *.run^I^I^Isetf ampl
Executing: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 93: 
Executing: 
line 94: " Ant
Executing: " Ant
line 95: au BufNewFile,BufRead build.xml^I^I^Isetf ant
Executing: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 96: 
Executing: 
line 97: " Arduino
Executing: " Arduino
line 98: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
Executing: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 99: 
Executing: 
line 100: " Apache config file
Executing: " Apache config file
line 101: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
Executing: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 102: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache
Executing: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache
line 103: 
Executing: 
line 104: " XA65 MOS6510 cross assembler
Executing: " XA65 MOS6510 cross assembler
line 105: au BufNewFile,BufRead *.a65^I^I^Isetf a65
Executing: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 106: 
Executing: 
line 107: " Applescript
Executing: " Applescript
line 108: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
Executing: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 109: 
Executing: 
line 110: " Applix ELF
Executing: " Applix ELF
line 111: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
Executing: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 113: 
Executing: 
line 114: " ALSA configuration
Executing: " ALSA configuration
line 115: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
Executing: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 116: 
Executing: 
line 117: " Arc Macro Language
Executing: " Arc Macro Language
line 118: au BufNewFile,BufRead *.aml^I^I^Isetf aml
Executing: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 119: 
Executing: 
line 120: " APT config file
Executing: " APT config file
line 121: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
Executing: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 122: au BufNewFile,BufRead */.aptitude/config       setf aptconf
Executing: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 123: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
Executing: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 124: 
Executing: 
line 125: " Arch Inventory file
Executing: " Arch Inventory file
line 126: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
Executing: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 127: 
Executing: 
line 128: " ART*Enterprise (formerly ART-IM)
Executing: " ART*Enterprise (formerly ART-IM)
line 129: au BufNewFile,BufRead *.art^I^I^Isetf art
Executing: au BufNewFile,BufRead *.art^I^I^Isetf art
line 130: 
Executing: 
line 131: " AsciiDoc
Executing: " AsciiDoc
line 132: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
Executing: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 133: 
Executing: 
line 134: " ASN.1
Executing: " ASN.1
line 135: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
Executing: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 136: 
Executing: 
line 137: " Active Server Pages (with Visual Basic Script)
Executing: " Active Server Pages (with Visual Basic Script)
line 138: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
Executing: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 144: 
Executing: 
line 145: " Active Server Pages (with Perl or Visual Basic Script)
Executing: " Active Server Pages (with Perl or Visual Basic Script)
line 146: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
Executing: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 154: 
Executing: 
line 155: " Grub (must be before catch *.lst)
Executing: " Grub (must be before catch *.lst)
line 156: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
Executing: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 157: 
Executing: 
line 158: " Assembly (all kinds)
Executing: " Assembly (all kinds)
line 159: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
Executing: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 160: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
Executing: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 161: 
Executing: 
line 162: " Macro (VAX)
Executing: " Macro (VAX)
line 163: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
Executing: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 164: 
Executing: 
line 165: " Atlas
Executing: " Atlas
line 166: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
Executing: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 167: 
Executing: 
line 168: " Autoit v3
Executing: " Autoit v3
line 169: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
Executing: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 170: 
Executing: 
line 171: " Autohotkey
Executing: " Autohotkey
line 172: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
Executing: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 173: 
Executing: 
line 174: " Automake
Executing: " Automake
line 175: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
Executing: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 176: 
Executing: 
line 177: " Autotest .at files are actually m4
Executing: " Autotest .at files are actually m4
line 178: au BufNewFile,BufRead *.at^I^I^Isetf m4
Executing: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 179: 
Executing: 
line 180: " Avenue
Executing: " Avenue
line 181: au BufNewFile,BufRead *.ave^I^I^Isetf ave
Executing: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 182: 
Executing: 
line 183: " Awk
Executing: " Awk
line 184: au BufNewFile,BufRead *.awk^I^I^Isetf awk
Executing: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 185: 
Executing: 
line 186: " B
Executing: " B
line 187: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
Executing: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 188: 
Executing: 
line 189: " BASIC or Visual Basic
Executing: " BASIC or Visual Basic
line 190: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")
Executing: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")
line 191: 
Executing: 
line 192: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
Executing: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 193: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
Executing: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 194: 
Executing: 
line 195: " IBasic file (similar to QBasic)
Executing: " IBasic file (similar to QBasic)
line 196: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
Executing: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 197: 
Executing: 
line 198: " FreeBasic file (similar to QBasic)
Executing: " FreeBasic file (similar to QBasic)
line 199: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
Executing: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 200: 
Executing: 
line 201: " Batch file for MSDOS.
Executing: " Batch file for MSDOS.
line 202: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
Executing: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 203: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
Executing: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 204: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
Executing: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 206: 
Executing: 
line 207: " Batch file for 4DOS
Executing: " Batch file for 4DOS
line 208: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
Executing: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 209: 
Executing: 
line 210: " BC calculator
Executing: " BC calculator
line 211: au BufNewFile,BufRead *.bc^I^I^Isetf bc
Executing: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 212: 
Executing: 
line 213: " BDF font
Executing: " BDF font
line 214: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
Executing: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 215: 
Executing: 
line 216: " BibTeX bibliography database file
Executing: " BibTeX bibliography database file
line 217: au BufNewFile,BufRead *.bib^I^I^Isetf bib
Executing: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 218: 
Executing: 
line 219: " BibTeX Bibliography Style
Executing: " BibTeX Bibliography Style
line 220: au BufNewFile,BufRead *.bst^I^I^Isetf bst
Executing: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 221: 
Executing: 
line 222: " BIND configuration
Executing: " BIND configuration
line 223: " sudoedit uses namedXXXX.conf
Executing: " sudoedit uses namedXXXX.conf
line 224: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
Executing: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 225: 
Executing: 
line 226: " BIND zone
Executing: " BIND zone
line 227: au BufNewFile,BufRead named.root^I^Isetf bindzone
Executing: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 228: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
Executing: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 229: 
Executing: 
line 230: " Blank
Executing: " Blank
line 231: au BufNewFile,BufRead *.bl^I^I^Isetf blank
Executing: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 232: 
Executing: 
line 233: " Blkid cache file
Executing: " Blkid cache file
line 234: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
Executing: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 235: 
Executing: 
line 236: " Bazel (http://bazel.io)
Executing: " Bazel (http://bazel.io)
line 237: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl
Executing: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl
line 238: if has("fname_case")
Executing: if has("fname_case")
line 239:   " There is another check for BUILD further below.
Executing:   " There is another check for BUILD further below.
line 240:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl
Executing:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl
line 241: endif
Executing: endif
line 242: 
Executing: 
line 243: " C or lpc
Executing: " C or lpc
line 244: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
Executing: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 245: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
Executing: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 246: 
Executing: 
line 247: " Calendar
Executing: " Calendar
line 248: au BufNewFile,BufRead calendar^I^I^Isetf calendar
Executing: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 249: 
Executing: 
line 250: " C#
Executing: " C#
line 251: au BufNewFile,BufRead *.cs^I^I^Isetf cs
Executing: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 252: 
Executing: 
line 253: " CSDL
Executing: " CSDL
line 254: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
Executing: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 255: 
Executing: 
line 256: " Cabal
Executing: " Cabal
line 257: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
Executing: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 258: 
Executing: 
line 259: " Cdrdao TOC
Executing: " Cdrdao TOC
line 260: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
Executing: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 261: 
Executing: 
line 262: " Cdrdao config
Executing: " Cdrdao config
line 263: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
Executing: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 264: 
Executing: 
line 265: " Cfengine
Executing: " Cfengine
line 266: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
Executing: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 267: 
Executing: 
line 268: " ChaiScript
Executing: " ChaiScript
line 269: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
Executing: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 270: 
Executing: 
line 271: " Comshare Dimension Definition Language
Executing: " Comshare Dimension Definition Language
line 272: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
Executing: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 273: 
Executing: 
line 274: " Conary Recipe
Executing: " Conary Recipe
line 275: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
Executing: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 276: 
Executing: 
line 277: " Controllable Regex Mutilator
Executing: " Controllable Regex Mutilator
line 278: au BufNewFile,BufRead *.crm^I^I^Isetf crm
Executing: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 279: 
Executing: 
line 280: " Cyn++
Executing: " Cyn++
line 281: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
Executing: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 282: 
Executing: 
line 283: " Cynlib
Executing: " Cynlib
line 284: " .cc and .cpp files can be C++ or Cynlib.
Executing: " .cc and .cpp files can be C++ or Cynlib.
line 285: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
Executing: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 287: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
Executing: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 289: 
Executing: 
line 290: " C++
Executing: " C++
line 291: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
Executing: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 292: if has("fname_case")
Executing: if has("fname_case")
line 293:   au BufNewFile,BufRead *.C,*.H setf cpp
Executing:   au BufNewFile,BufRead *.C,*.H setf cpp
line 294: endif
Executing: endif
line 295: 
Executing: 
line 296: " .h files can be C, Ch C++, ObjC or ObjC++.
Executing: " .h files can be C, Ch C++, ObjC or ObjC++.
line 297: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
Executing: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 298: " detected automatically.
Executing: " detected automatically.
line 299: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
Executing: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 300: 
Executing: 
line 301: " Ch (CHscript)
Executing: " Ch (CHscript)
line 302: au BufNewFile,BufRead *.chf^I^I^Isetf ch
Executing: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 303: 
Executing: 
line 304: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
Executing: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 305: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
Executing: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 306: 
Executing: 
line 307: " Cascading Style Sheets
Executing: " Cascading Style Sheets
line 308: au BufNewFile,BufRead *.css^I^I^Isetf css
Executing: au BufNewFile,BufRead *.css^I^I^Isetf css
line 309: 
Executing: 
line 310: " Century Term Command Scripts (*.cmd too)
Executing: " Century Term Command Scripts (*.cmd too)
line 311: au BufNewFile,BufRead *.con^I^I^Isetf cterm
Executing: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 312: 
Executing: 
line 313: " Changelog
Executing: " Changelog
line 314: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
Executing: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 316: 
Executing: 
line 317: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
Executing: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 323: 
Executing: 
line 324: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
Executing: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 328: 
Executing: 
line 329: " CHILL
Executing: " CHILL
line 330: au BufNewFile,BufRead *..ch^I^I^Isetf chill
Executing: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 331: 
Executing: 
line 332: " Changes for WEB and CWEB or CHILL
Executing: " Changes for WEB and CWEB or CHILL
line 333: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
Executing: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 334: 
Executing: 
line 335: " ChordPro
Executing: " ChordPro
line 336: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
Executing: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 337: 
Executing: 
line 338: " Clean
Executing: " Clean
line 339: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
Executing: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 340: 
Executing: 
line 341: " Clever
Executing: " Clever
line 342: au BufNewFile,BufRead *.eni^I^I^Isetf cl
Executing: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 343: 
Executing: 
line 344: " Clever or dtd
Executing: " Clever or dtd
line 345: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
Executing: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 346: 
Executing: 
line 347: " Clipper (or FoxPro; could also be eviews)
Executing: " Clipper (or FoxPro; could also be eviews)
line 348: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
Executing: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 354: 
Executing: 
line 355: " Clojure
Executing: " Clojure
line 356: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
Executing: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 357: 
Executing: 
line 358: " Cmake
Executing: " Cmake
line 359: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
Executing: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 360: 
Executing: 
line 361: " Cmusrc
Executing: " Cmusrc
line 362: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
Executing: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 363: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
Executing: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 364: 
Executing: 
line 365: " Cobol
Executing: " Cobol
line 366: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
Executing: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 367: "   cobol or zope form controller python script? (heuristic)
Executing: "   cobol or zope form controller python script? (heuristic)
line 368: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
Executing: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 374: 
Executing: 
line 375: " Coco/R
Executing: " Coco/R
line 376: au BufNewFile,BufRead *.atg^I^I^Isetf coco
Executing: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 377: 
Executing: 
line 378: " Cold Fusion
Executing: " Cold Fusion
line 379: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
Executing: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 380: 
Executing: 
line 381: " Configure scripts
Executing: " Configure scripts
line 382: au BufNewFile,BufRead configure.in,configure.ac setf config
Executing: au BufNewFile,BufRead configure.in,configure.ac setf config
line 383: 
Executing: 
line 384: " CUDA  Cumpute Unified Device Architecture
Executing: " CUDA  Cumpute Unified Device Architecture
line 385: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
Executing: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 386: 
Executing: 
line 387: " Dockerfilb; Podman uses the same syntax with name Containerfile
Executing: " Dockerfilb; Podman uses the same syntax with name Containerfile
line 388: au BufNewFile,BufRead Containerfile,Dockerfile,*.Dockerfile^Isetf dockerfile
Executing: au BufNewFile,BufRead Containerfile,Dockerfile,*.Dockerfile^Isetf dockerfile
line 389: 
Executing: 
line 390: " WildPackets EtherPeek Decoder
Executing: " WildPackets EtherPeek Decoder
line 391: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
Executing: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 392: 
Executing: 
line 393: " Enlightenment configuration files
Executing: " Enlightenment configuration files
line 394: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
Executing: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 395: 
Executing: 
line 396: " Eterm
Executing: " Eterm
line 397: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
Executing: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 398: 
Executing: 
line 399: " Euphoria 3 or 4
Executing: " Euphoria 3 or 4
line 400: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
Executing: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 401: if has("fname_case")
Executing: if has("fname_case")
line 402:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
Executing:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 403: endif
Executing: endif
line 404: 
Executing: 
line 405: " Lynx config files
Executing: " Lynx config files
line 406: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
Executing: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 407: 
Executing: 
line 408: " Quake
Executing: " Quake
line 409: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
Executing: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 410: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
Executing: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 411: 
Executing: 
line 412: " Quake C
Executing: " Quake C
line 413: au BufNewFile,BufRead *.qc^I^I^Isetf c
Executing: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 414: 
Executing: 
line 415: " Configure files
Executing: " Configure files
line 416: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
Executing: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 417: 
Executing: 
line 418: " Cucumber
Executing: " Cucumber
line 419: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
Executing: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 420: 
Executing: 
line 421: " Communicating Sequential Processes
Executing: " Communicating Sequential Processes
line 422: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
Executing: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 423: 
Executing: 
line 424: " CUPL logic description and simulation
Executing: " CUPL logic description and simulation
line 425: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
Executing: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 426: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
Executing: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 427: 
Executing: 
line 428: " Dart
Executing: " Dart
line 429: au BufRead,BufNewfile *.dart,*.drt^I^Isetf dart
Executing: au BufRead,BufNewfile *.dart,*.drt^I^Isetf dart
line 430: 
Executing: 
line 431: " Debian Control
Executing: " Debian Control
line 432: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
Executing: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 433: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
Executing: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 437: 
Executing: 
line 438: " Debian Copyright
Executing: " Debian Copyright
line 439: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
Executing: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 440: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
Executing: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 444: 
Executing: 
line 445: " Debian Sources.list
Executing: " Debian Sources.list
line 446: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
Executing: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 447: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
Executing: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 448: 
Executing: 
line 449: " Deny hosts
Executing: " Deny hosts
line 450: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
Executing: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 451: 
Executing: 
line 452: " dnsmasq(8) configuration files
Executing: " dnsmasq(8) configuration files
line 453: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
Executing: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 454: 
Executing: 
line 455: " ROCKLinux package description
Executing: " ROCKLinux package description
line 456: au BufNewFile,BufRead *.desc^I^I^Isetf desc
Executing: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 457: 
Executing: 
line 458: " the D language or dtrace
Executing: " the D language or dtrace
line 459: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
Executing: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 460: 
Executing: 
line 461: " Desktop files
Executing: " Desktop files
line 462: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
Executing: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 463: 
Executing: 
line 464: " Dict config
Executing: " Dict config
line 465: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
Executing: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 466: 
Executing: 
line 467: " Dictd config
Executing: " Dictd config
line 468: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
Executing: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 469: 
Executing: 
line 470: " Diff files
Executing: " Diff files
line 471: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
Executing: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 472: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
Executing: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 478: 
Executing: 
line 479: " Dircolors
Executing: " Dircolors
line 480: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
Executing: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 481: 
Executing: 
line 482: " Diva (with Skill) or InstallShield
Executing: " Diva (with Skill) or InstallShield
line 483: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
Executing: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 489: 
Executing: 
line 490: " DCL (Digital Command Language - vms) or DNS zone file
Executing: " DCL (Digital Command Language - vms) or DNS zone file
line 491: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
Executing: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 492: 
Executing: 
line 493: " DOT
Executing: " DOT
line 494: au BufNewFile,BufRead *.dot^I^I^Isetf dot
Executing: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 495: 
Executing: 
line 496: " Dylan - lid files
Executing: " Dylan - lid files
line 497: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
Executing: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 498: 
Executing: 
line 499: " Dylan - intr files (melange)
Executing: " Dylan - intr files (melange)
line 500: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
Executing: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 501: 
Executing: 
line 502: " Dylan
Executing: " Dylan
line 503: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
Executing: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 504: 
Executing: 
line 505: " Microsoft Module Definition
Executing: " Microsoft Module Definition
line 506: au BufNewFile,BufRead *.def^I^I^Isetf def
Executing: au BufNewFile,BufRead *.def^I^I^Isetf def
line 507: 
Executing: 
line 508: " Dracula
Executing: " Dracula
line 509: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
Executing: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 510: 
Executing: 
line 511: " Datascript
Executing: " Datascript
line 512: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
Executing: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 513: 
Executing: 
line 514: " dsl
Executing: " dsl
line 515: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
Executing: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 516: 
Executing: 
line 517: " DTD (Document Type Definition for XML)
Executing: " DTD (Document Type Definition for XML)
line 518: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
Executing: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 519: 
Executing: 
line 520: " DTS/DSTI (device tree files)
Executing: " DTS/DSTI (device tree files)
line 521: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
Executing: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 522: 
Executing: 
line 523: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
Executing: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 524: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
Executing: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 525: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
Executing: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 531: 
Executing: 
line 532: " EditorConfig (close enough to dosini)
Executing: " EditorConfig (close enough to dosini)
line 533: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
Executing: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
line 534: 
Executing: 
line 535: " Embedix Component Description
Executing: " Embedix Component Description
line 536: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
Executing: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 537: 
Executing: 
line 538: " Eiffel or Specman or Euphoria
Executing: " Eiffel or Specman or Euphoria
line 539: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
Executing: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 540: 
Executing: 
line 541: " Elinks configuration
Executing: " Elinks configuration
line 542: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
Executing: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 543: 
Executing: 
line 544: " ERicsson LANGuage; Yaws is erlang too
Executing: " ERicsson LANGuage; Yaws is erlang too
line 545: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
Executing: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 546: 
Executing: 
line 547: " Elm Filter Rules file
Executing: " Elm Filter Rules file
line 548: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
Executing: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 549: 
Executing: 
line 550: " ESMTP rc file
Executing: " ESMTP rc file
line 551: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
Executing: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 552: 
Executing: 
line 553: " ESQL-C
Executing: " ESQL-C
line 554: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
Executing: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 555: 
Executing: 
line 556: " Esterel
Executing: " Esterel
line 557: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
Executing: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 558: 
Executing: 
line 559: " Essbase script
Executing: " Essbase script
line 560: au BufNewFile,BufRead *.csc^I^I^Isetf csc
Executing: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 561: 
Executing: 
line 562: " Exim
Executing: " Exim
line 563: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
Executing: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 564: 
Executing: 
line 565: " Expect
Executing: " Expect
line 566: au BufNewFile,BufRead *.exp^I^I^Isetf expect
Executing: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 567: 
Executing: 
line 568: " Exports
Executing: " Exports
line 569: au BufNewFile,BufRead exports^I^I^Isetf exports
Executing: au BufNewFile,BufRead exports^I^I^Isetf exports
line 570: 
Executing: 
line 571: " Falcon
Executing: " Falcon
line 572: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
Executing: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 573: 
Executing: 
line 574: " Fantom
Executing: " Fantom
line 575: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
Executing: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 576: 
Executing: 
line 577: " Factor
Executing: " Factor
line 578: au BufNewFile,BufRead *.factor^I^I^Isetf factor
Executing: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 579: 
Executing: 
line 580: " Fetchmail RC file
Executing: " Fetchmail RC file
line 581: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
Executing: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 582: 
Executing: 
line 583: " FlexWiki - disabled, because it has side effects when a .wiki file
Executing: " FlexWiki - disabled, because it has side effects when a .wiki file
line 584: " is not actually FlexWiki
Executing: " is not actually FlexWiki
line 585: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
Executing: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 586: 
Executing: 
line 587: " Focus Executable
Executing: " Focus Executable
line 588: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
Executing: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 589: 
Executing: 
line 590: " Focus Master file (but not for auto.master)
Executing: " Focus Master file (but not for auto.master)
line 591: au BufNewFile,BufRead auto.master^I^Isetf conf
Executing: au BufNewFile,BufRead auto.master^I^Isetf conf
line 592: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
Executing: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 593: 
Executing: 
line 594: " Forth
Executing: " Forth
line 595: au BufNewFile,BufRead *.fs,*.ft,*.fth^I^Isetf forth
Executing: au BufNewFile,BufRead *.fs,*.ft,*.fth^I^Isetf forth
line 596: 
Executing: 
line 597: " Reva Forth
Executing: " Reva Forth
line 598: au BufNewFile,BufRead *.frt^I^I^Isetf reva
Executing: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 599: 
Executing: 
line 600: " Fortran
Executing: " Fortran
line 601: if has("fname_case")
Executing: if has("fname_case")
line 602:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
Executing:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 603: endif
Executing: endif
line 604: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
Executing: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 605: 
Executing: 
line 606: " Framescript
Executing: " Framescript
line 607: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
Executing: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 608: 
Executing: 
line 609: " FStab
Executing: " FStab
line 610: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
Executing: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 611: 
Executing: 
line 612: " GDB command files
Executing: " GDB command files
line 613: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
Executing: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 614: 
Executing: 
line 615: " GDMO
Executing: " GDMO
line 616: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
Executing: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 617: 
Executing: 
line 618: " Gedcom
Executing: " Gedcom
line 619: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
Executing: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 620: 
Executing: 
line 621: " Git
Executing: " Git
line 622: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG ^Isetf gitcommit
Executing: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG ^Isetf gitcommit
line 623: au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig ^Isetf gitconfig
Executing: au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig ^Isetf gitconfig
line 624: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
Executing: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 625: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
Executing: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 626: if !empty($XDG_CONFIG_HOME)
Executing: if !empty($XDG_CONFIG_HOME)
line 627:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
Executing:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 628: endif
Executing: endif
line 629: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
Executing: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 630: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
Executing: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
line 631: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
Executing: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 635: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
Executing: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 639: 
Executing: 
line 640: " Gkrellmrc
Executing: " Gkrellmrc
line 641: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
Executing: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 642: 
Executing: 
line 643: " GP scripts (2.0 and onward)
Executing: " GP scripts (2.0 and onward)
line 644: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
Executing: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 645: 
Executing: 
line 646: " GPG
Executing: " GPG
line 647: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
Executing: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 648: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
Executing: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 649: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
Executing: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 650: if !empty($GNUPGHOME)
Executing: if !empty($GNUPGHOME)
line 651:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
Executing:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 652:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
Executing:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 653: endif
Executing: endif
line 654: 
Executing: 
line 655: " gnash(1) configuration files
Executing: " gnash(1) configuration files
line 656: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
Executing: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 657: 
Executing: 
line 658: " Gitolite
Executing: " Gitolite
line 659: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
Executing: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 660: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
Executing: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 661: 
Executing: 
line 662: " Gnuplot scripts
Executing: " Gnuplot scripts
line 663: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
Executing: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 664: 
Executing: 
line 665: " Go (Google)
Executing: " Go (Google)
line 666: au BufNewFile,BufRead *.go^I^I^Isetf go
Executing: au BufNewFile,BufRead *.go^I^I^Isetf go
line 667: 
Executing: 
line 668: " GrADS scripts
Executing: " GrADS scripts
line 669: au BufNewFile,BufRead *.gs^I^I^Isetf grads
Executing: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 670: 
Executing: 
line 671: " Gretl
Executing: " Gretl
line 672: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
Executing: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 673: 
Executing: 
line 674: " Groovy
Executing: " Groovy
line 675: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
Executing: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 676: 
Executing: 
line 677: " GNU Server Pages
Executing: " GNU Server Pages
line 678: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
Executing: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 679: 
Executing: 
line 680: " Group file
Executing: " Group file
line 681: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
Executing: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 682: 
Executing: 
line 683: " GTK RC
Executing: " GTK RC
line 684: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
Executing: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 685: 
Executing: 
line 686: " Haml
Executing: " Haml
line 687: au BufNewFile,BufRead *.haml^I^I^Isetf haml
Executing: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 688: 
Executing: 
line 689: " Hamster Classic | Playground files
Executing: " Hamster Classic | Playground files
line 690: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
Executing: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 691: 
Executing: 
line 692: " Haskell
Executing: " Haskell
line 693: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
Executing: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 694: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
Executing: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 695: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
Executing: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 696: 
Executing: 
line 697: " Haste
Executing: " Haste
line 698: au BufNewFile,BufRead *.ht^I^I^Isetf haste
Executing: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 699: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
Executing: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 700: 
Executing: 
line 701: " Hercules
Executing: " Hercules
line 702: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
Executing: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 703: 
Executing: 
line 704: " HEX (Intel)
Executing: " HEX (Intel)
line 705: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
Executing: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 706: 
Executing: 
line 707: " Hollywood
Executing: " Hollywood
line 708: au BufRead,BufNewFile *.hws^I^I^Isetf hollywood
Executing: au BufRead,BufNewFile *.hws^I^I^Isetf hollywood
line 709: 
Executing: 
line 710: " Tilde (must be before HTML)
Executing: " Tilde (must be before HTML)
line 711: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
Executing: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 712: 
Executing: 
line 713: " HTML (.shtml and .stm for server side)
Executing: " HTML (.shtml and .stm for server side)
line 714: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
Executing: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 715: 
Executing: 
line 716: " HTML with Ruby - eRuby
Executing: " HTML with Ruby - eRuby
line 717: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
Executing: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 718: 
Executing: 
line 719: " HTML with M4
Executing: " HTML with M4
line 720: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
Executing: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 721: 
Executing: 
line 722: " Some template.  Used to be HTML Cheetah.
Executing: " Some template.  Used to be HTML Cheetah.
line 723: au BufNewFile,BufRead *.tmpl^I^I^Isetf template
Executing: au BufNewFile,BufRead *.tmpl^I^I^Isetf template
line 724: 
Executing: 
line 725: " Host config
Executing: " Host config
line 726: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
Executing: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 727: 
Executing: 
line 728: " Hosts access
Executing: " Hosts access
line 729: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
Executing: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 730: 
Executing: 
line 731: " Hyper Builder
Executing: " Hyper Builder
line 732: au BufNewFile,BufRead *.hb^I^I^Isetf hb
Executing: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 733: 
Executing: 
line 734: " Httest
Executing: " Httest
line 735: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
Executing: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 736: 
Executing: 
line 737: " Icon
Executing: " Icon
line 738: au BufNewFile,BufRead *.icn^I^I^Isetf icon
Executing: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 739: 
Executing: 
line 740: " IDL (Interface Description Language)
Executing: " IDL (Interface Description Language)
line 741: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
Executing: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 742: 
Executing: 
line 743: " Microsoft IDL (Interface Description Language)  Also *.idl
Executing: " Microsoft IDL (Interface Description Language)  Also *.idl
line 744: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
Executing: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 745: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
Executing: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 746: 
Executing: 
line 747: " Icewm menu
Executing: " Icewm menu
line 748: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
Executing: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 749: 
Executing: 
line 750: " Indent profile (must come before IDL *.pro!)
Executing: " Indent profile (must come before IDL *.pro!)
line 751: au BufNewFile,BufRead .indent.pro^I^Isetf indent
Executing: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 752: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
Executing: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 753: 
Executing: 
line 754: " IDL (Interactive Data Language)
Executing: " IDL (Interactive Data Language)
line 755: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
Executing: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 756: 
Executing: 
line 757: " Indent RC
Executing: " Indent RC
line 758: au BufNewFile,BufRead indentrc^I^I^Isetf indent
Executing: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 759: 
Executing: 
line 760: " Inform
Executing: " Inform
line 761: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
Executing: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 762: 
Executing: 
line 763: " Initng
Executing: " Initng
line 764: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
Executing: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 765: 
Executing: 
line 766: " Innovation Data Processing
Executing: " Innovation Data Processing
line 767: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
Executing: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 768: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
Executing: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
line 769: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
Executing: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 770: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
Executing: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 771: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
Executing: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 772: 
Executing: 
line 773: " Ipfilter
Executing: " Ipfilter
line 774: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
Executing: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 775: 
Executing: 
line 776: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
Executing: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 777: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
Executing: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 778: 
Executing: 
line 779: " .INI file for MSDOS
Executing: " .INI file for MSDOS
line 780: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
Executing: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 781: 
Executing: 
line 782: " SysV Inittab
Executing: " SysV Inittab
line 783: au BufNewFile,BufRead inittab^I^I^Isetf inittab
Executing: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 784: 
Executing: 
line 785: " Inno Setup
Executing: " Inno Setup
line 786: au BufNewFile,BufRead *.iss^I^I^Isetf iss
Executing: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 787: 
Executing: 
line 788: " J
Executing: " J
line 789: au BufNewFile,BufRead *.ijs^I^I^Isetf j
Executing: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 790: 
Executing: 
line 791: " JAL
Executing: " JAL
line 792: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
Executing: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 793: 
Executing: 
line 794: " Jam
Executing: " Jam
line 795: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
Executing: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 796: 
Executing: 
line 797: " Java
Executing: " Java
line 798: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
Executing: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 799: 
Executing: 
line 800: " JavaCC
Executing: " JavaCC
line 801: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
Executing: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 802: 
Executing: 
line 803: " JavaScript, ECMAScript
Executing: " JavaScript, ECMAScript
line 804: au BufNewFile,BufRead *.js,*.javascript,*.es,*.mjs   setf javascript
Executing: au BufNewFile,BufRead *.js,*.javascript,*.es,*.mjs   setf javascript
line 805: 
Executing: 
line 806: " JavaScript with React
Executing: " JavaScript with React
line 807: au BufNewFile,BufRead *.jsx^I^I^Isetf javascriptreact
Executing: au BufNewFile,BufRead *.jsx^I^I^Isetf javascriptreact
line 808: 
Executing: 
line 809: " Java Server Pages
Executing: " Java Server Pages
line 810: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
Executing: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 811: 
Executing: 
line 812: " Java Properties resource file (note: doesn't catch font.properties.pl)
Executing: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 813: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
Executing: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 814: 
Executing: 
line 815: " Jess
Executing: " Jess
line 816: au BufNewFile,BufRead *.clp^I^I^Isetf jess
Executing: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 817: 
Executing: 
line 818: " Jgraph
Executing: " Jgraph
line 819: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
Executing: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 820: 
Executing: 
line 821: " Jovial
Executing: " Jovial
line 822: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
Executing: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 823: 
Executing: 
line 824: " JSON
Executing: " JSON
line 825: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
Executing: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 826: 
Executing: 
line 827: " Kixtart
Executing: " Kixtart
line 828: au BufNewFile,BufRead *.kix^I^I^Isetf kix
Executing: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 829: 
Executing: 
line 830: " Kimwitu[++]
Executing: " Kimwitu[++]
line 831: au BufNewFile,BufRead *.k^I^I^Isetf kwt
Executing: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 832: 
Executing: 
line 833: " Kivy
Executing: " Kivy
line 834: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
Executing: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 835: 
Executing: 
line 836: " KDE script
Executing: " KDE script
line 837: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
Executing: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 838: 
Executing: 
line 839: " Kconfig
Executing: " Kconfig
line 840: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
Executing: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 841: 
Executing: 
line 842: " Lace (ISE)
Executing: " Lace (ISE)
line 843: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
Executing: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 844: 
Executing: 
line 845: " Latte
Executing: " Latte
line 846: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
Executing: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 847: 
Executing: 
line 848: " Limits
Executing: " Limits
line 849: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
Executing: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 850: 
Executing: 
line 851: " LambdaProlog (*.mod too, see Modsim)
Executing: " LambdaProlog (*.mod too, see Modsim)
line 852: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
Executing: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 853: 
Executing: 
line 854: " LDAP LDIF
Executing: " LDAP LDIF
line 855: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
Executing: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 856: 
Executing: 
line 857: " Ld loader
Executing: " Ld loader
line 858: au BufNewFile,BufRead *.ld^I^I^Isetf ld
Executing: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 859: 
Executing: 
line 860: " Less
Executing: " Less
line 861: au BufNewFile,BufRead *.less^I^I^Isetf less
Executing: au BufNewFile,BufRead *.less^I^I^Isetf less
line 862: 
Executing: 
line 863: " Lex
Executing: " Lex
line 864: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
Executing: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 865: 
Executing: 
line 866: " Libao
Executing: " Libao
line 867: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
Executing: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 868: 
Executing: 
line 869: " Libsensors
Executing: " Libsensors
line 870: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
Executing: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 871: 
Executing: 
line 872: " LFTP
Executing: " LFTP
line 873: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
Executing: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 874: 
Executing: 
line 875: " Lifelines (or Lex for C++!)
Executing: " Lifelines (or Lex for C++!)
line 876: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
Executing: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 877: 
Executing: 
line 878: " Lilo: Linux loader
Executing: " Lilo: Linux loader
line 879: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
Executing: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 880: 
Executing: 
line 881: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
Executing: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 882: if has("fname_case")
Executing: if has("fname_case")
line 883:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
Executing:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 884: else
Executing: else
line 885:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
Executing:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 886: endif
Executing: endif
line 887: 
Executing: 
line 888: " SBCL implementation of Common Lisp
Executing: " SBCL implementation of Common Lisp
line 889: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
Executing: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 890: 
Executing: 
line 891: " Liquid
Executing: " Liquid
line 892: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
Executing: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 893: 
Executing: 
line 894: " Lite
Executing: " Lite
line 895: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
Executing: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 896: 
Executing: 
line 897: " LiteStep RC files
Executing: " LiteStep RC files
line 898: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
Executing: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 899: 
Executing: 
line 900: " Login access
Executing: " Login access
line 901: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
Executing: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 902: 
Executing: 
line 903: " Login defs
Executing: " Login defs
line 904: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
Executing: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 905: 
Executing: 
line 906: " Logtalk
Executing: " Logtalk
line 907: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
Executing: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 908: 
Executing: 
line 909: " LOTOS
Executing: " LOTOS
line 910: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
Executing: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 911: 
Executing: 
line 912: " Lout (also: *.lt)
Executing: " Lout (also: *.lt)
line 913: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
Executing: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 914: 
Executing: 
line 915: " Lua
Executing: " Lua
line 916: au BufNewFile,BufRead *.lua^I^I^Isetf lua
Executing: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 917: 
Executing: 
line 918: " Luarocks
Executing: " Luarocks
line 919: au BufNewFile,BufRead *.rockspec^I^Isetf lua
Executing: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 920: 
Executing: 
line 921: " Linden Scripting Language (Second Life)
Executing: " Linden Scripting Language (Second Life)
line 922: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
Executing: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 923: 
Executing: 
line 924: " Lynx style file (or LotusScript!)
Executing: " Lynx style file (or LotusScript!)
line 925: au BufNewFile,BufRead *.lss^I^I^Isetf lss
Executing: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 926: 
Executing: 
line 927: " M4
Executing: " M4
line 928: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
Executing: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 930: 
Executing: 
line 931: " MaGic Point
Executing: " MaGic Point
line 932: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
Executing: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 933: 
Executing: 
line 934: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
Executing: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 935: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
Executing: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 936: 
Executing: 
line 937: " Mail aliases
Executing: " Mail aliases
line 938: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
Executing: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 939: 
Executing: 
line 940: " Mailcap configuration file
Executing: " Mailcap configuration file
line 941: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
Executing: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 942: 
Executing: 
line 943: " Makefile
Executing: " Makefile
line 944: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
Executing: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 945: 
Executing: 
line 946: " MakeIndex
Executing: " MakeIndex
line 947: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
Executing: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 948: 
Executing: 
line 949: " Mallard
Executing: " Mallard
line 950: au BufNewFile,BufRead *.page^I^I^Isetf mallard
Executing: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 951: 
Executing: 
line 952: " Manpage
Executing: " Manpage
line 953: au BufNewFile,BufRead *.man^I^I^Isetf man
Executing: au BufNewFile,BufRead *.man^I^I^Isetf man
line 954: 
Executing: 
line 955: " Man config
Executing: " Man config
line 956: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
Executing: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 957: 
Executing: 
line 958: " Maple V
Executing: " Maple V
line 959: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
Executing: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 960: 
Executing: 
line 961: " Map (UMN mapserver config file)
Executing: " Map (UMN mapserver config file)
line 962: au BufNewFile,BufRead *.map^I^I^Isetf map
Executing: au BufNewFile,BufRead *.map^I^I^Isetf map
line 963: 
Executing: 
line 964: " Markdown
Executing: " Markdown
line 965: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
Executing: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 966: 
Executing: 
line 967: " Mason
Executing: " Mason
line 968: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
Executing: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 969: 
Executing: 
line 970: " Mathematica, Matlab, Murphi or Objective C
Executing: " Mathematica, Matlab, Murphi or Objective C
line 971: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
Executing: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 972: 
Executing: 
line 973: " Mathematica notebook
Executing: " Mathematica notebook
line 974: au BufNewFile,BufRead *.nb^I^I^Isetf mma
Executing: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 975: 
Executing: 
line 976: " Maya Extension Language
Executing: " Maya Extension Language
line 977: au BufNewFile,BufRead *.mel^I^I^Isetf mel
Executing: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 978: 
Executing: 
line 979: " Mercurial (hg) commit file
Executing: " Mercurial (hg) commit file
line 980: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
Executing: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 981: 
Executing: 
line 982: " Mercurial config (looks like generic config file)
Executing: " Mercurial config (looks like generic config file)
line 983: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
Executing: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 984: 
Executing: 
line 985: " Meson Build system config
Executing: " Meson Build system config
line 986: au BufNewFile,BufRead meson.build,meson_options.txt setf meson
Executing: au BufNewFile,BufRead meson.build,meson_options.txt setf meson
line 987: 
Executing: 
line 988: " Messages (logs mostly)
Executing: " Messages (logs mostly)
line 989: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
Executing: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 990: 
Executing: 
line 991: " Metafont
Executing: " Metafont
line 992: au BufNewFile,BufRead *.mf^I^I^Isetf mf
Executing: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 993: 
Executing: 
line 994: " MetaPost
Executing: " MetaPost
line 995: au BufNewFile,BufRead *.mp^I^I^Isetf mp
Executing: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 996: 
Executing: 
line 997: " MGL
Executing: " MGL
line 998: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
Executing: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 999: 
Executing: 
line 1000: " MIX - Knuth assembly
Executing: " MIX - Knuth assembly
line 1001: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
Executing: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1002: 
Executing: 
line 1003: " MMIX or VMS makefile
Executing: " MMIX or VMS makefile
line 1004: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
Executing: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 1005: 
Executing: 
line 1006: " Symbian meta-makefile definition (MMP)
Executing: " Symbian meta-makefile definition (MMP)
line 1007: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
Executing: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1008: 
Executing: 
line 1009: " Modsim III (or LambdaProlog)
Executing: " Modsim III (or LambdaProlog)
line 1010: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
Executing: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1016: 
Executing: 
line 1017: " Modula 2  (.md removed in favor of Markdown)
Executing: " Modula 2  (.md removed in favor of Markdown)
line 1018: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
Executing: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1019: 
Executing: 
line 1020: " Modula 3 (.m3, .i3, .mg, .ig)
Executing: " Modula 3 (.m3, .i3, .mg, .ig)
line 1021: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
Executing: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1022: 
Executing: 
line 1023: " Monk
Executing: " Monk
line 1024: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
Executing: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1025: 
Executing: 
line 1026: " MOO
Executing: " MOO
line 1027: au BufNewFile,BufRead *.moo^I^I^Isetf moo
Executing: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1028: 
Executing: 
line 1029: " Modconf
Executing: " Modconf
line 1030: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
Executing: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1031: 
Executing: 
line 1032: " Mplayer config
Executing: " Mplayer config
line 1033: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
Executing: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1034: 
Executing: 
line 1035: " Motorola S record
Executing: " Motorola S record
line 1036: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
Executing: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1037: 
Executing: 
line 1038: " Mrxvtrc
Executing: " Mrxvtrc
line 1039: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
Executing: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1040: 
Executing: 
line 1041: " Msql
Executing: " Msql
line 1042: au BufNewFile,BufRead *.msql^I^I^Isetf msql
Executing: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1043: 
Executing: 
line 1044: " Mysql
Executing: " Mysql
line 1045: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
Executing: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1046: 
Executing: 
line 1047: " Mutt setup files (must be before catch *.rc)
Executing: " Mutt setup files (must be before catch *.rc)
line 1048: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
Executing: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1049: 
Executing: 
line 1050: " M$ Resource files
Executing: " M$ Resource files
line 1051: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
Executing: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1052: 
Executing: 
line 1053: " MuPAD source
Executing: " MuPAD source
line 1054: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
Executing: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1055: 
Executing: 
line 1056: " Mush
Executing: " Mush
line 1057: au BufNewFile,BufRead *.mush^I^I^Isetf mush
Executing: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1058: 
Executing: 
line 1059: " Mutt setup file (also for Muttng)
Executing: " Mutt setup file (also for Muttng)
line 1060: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
Executing: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1061: 
Executing: 
line 1062: " N1QL
Executing: " N1QL
line 1063: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
Executing: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1064: 
Executing: 
line 1065: " Nano
Executing: " Nano
line 1066: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
Executing: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1067: 
Executing: 
line 1068: " Nastran input/DMAP
Executing: " Nastran input/DMAP
line 1069: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
Executing: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1070: 
Executing: 
line 1071: " Natural
Executing: " Natural
line 1072: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
Executing: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1073: 
Executing: 
line 1074: " Noemutt setup file
Executing: " Noemutt setup file
line 1075: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
Executing: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1076: 
Executing: 
line 1077: " Netrc
Executing: " Netrc
line 1078: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
Executing: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1079: 
Executing: 
line 1080: " Ninja file
Executing: " Ninja file
line 1081: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
Executing: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1082: 
Executing: 
line 1083: " Novell netware batch files
Executing: " Novell netware batch files
line 1084: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
Executing: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1085: 
Executing: 
line 1086: " Nroff/Troff (*.ms and *.t are checked below)
Executing: " Nroff/Troff (*.ms and *.t are checked below)
line 1087: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
Executing: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1091: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
Executing: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1092: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
Executing: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1093: 
Executing: 
line 1094: " Nroff or Objective C++
Executing: " Nroff or Objective C++
line 1095: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
Executing: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1096: 
Executing: 
line 1097: " Not Quite C
Executing: " Not Quite C
line 1098: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
Executing: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1099: 
Executing: 
line 1100: " NSE - Nmap Script Engine - uses Lua syntax
Executing: " NSE - Nmap Script Engine - uses Lua syntax
line 1101: au BufNewFile,BufRead *.nse^I^I^Isetf lua
Executing: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1102: 
Executing: 
line 1103: " NSIS
Executing: " NSIS
line 1104: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
Executing: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1105: 
Executing: 
line 1106: " OCAML
Executing: " OCAML
line 1107: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
Executing: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1108: 
Executing: 
line 1109: " Occam
Executing: " Occam
line 1110: au BufNewFile,BufRead *.occ^I^I^Isetf occam
Executing: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1111: 
Executing: 
line 1112: " Omnimark
Executing: " Omnimark
line 1113: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
Executing: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1114: 
Executing: 
line 1115: " OpenROAD
Executing: " OpenROAD
line 1116: au BufNewFile,BufRead *.or^I^I^Isetf openroad
Executing: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1117: 
Executing: 
line 1118: " OPL
Executing: " OPL
line 1119: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
Executing: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1120: 
Executing: 
line 1121: " Oracle config file
Executing: " Oracle config file
line 1122: au BufNewFile,BufRead *.ora^I^I^Isetf ora
Executing: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1123: 
Executing: 
line 1124: " Packet filter conf
Executing: " Packet filter conf
line 1125: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
Executing: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1126: 
Executing: 
line 1127: " Pam conf
Executing: " Pam conf
line 1128: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
Executing: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1129: 
Executing: 
line 1130: " PApp
Executing: " PApp
line 1131: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
Executing: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1132: 
Executing: 
line 1133: " Password file
Executing: " Password file
line 1134: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
Executing: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1135: 
Executing: 
line 1136: " Pascal (also *.p)
Executing: " Pascal (also *.p)
line 1137: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
Executing: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1138: 
Executing: 
line 1139: " Delphi project file
Executing: " Delphi project file
line 1140: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
Executing: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1141: 
Executing: 
line 1142: " PDF
Executing: " PDF
line 1143: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
Executing: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1144: 
Executing: 
line 1145: " PCMK - HAE - crm configure edit
Executing: " PCMK - HAE - crm configure edit
line 1146: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk
Executing: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk
line 1147: 
Executing: 
line 1148: " Perl
Executing: " Perl
line 1149: if has("fname_case")
Executing: if has("fname_case")
line 1150:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()
Executing:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()
line 1151: else
Executing: else
line 1152:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()
Executing:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()
line 1153: endif
Executing: endif
line 1154: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
Executing: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
line 1155: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
Executing: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1156: 
Executing: 
line 1157: " Perl, XPM or XPM2
Executing: " Perl, XPM or XPM2
line 1158: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
Executing: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1166: 
Executing: 
line 1167: " Perl POD
Executing: " Perl POD
line 1168: au BufNewFile,BufRead *.pod^I^I^Isetf pod
Executing: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1169: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
Executing: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1170: 
Executing: 
line 1171: " Php, php3, php4, etc.
Executing: " Php, php3, php4, etc.
line 1172: " Also Phtml (was used for PHP 2 in the past)
Executing: " Also Phtml (was used for PHP 2 in the past)
line 1173: " Also .ctp for Cake template file
Executing: " Also .ctp for Cake template file
line 1174: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
Executing: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1175: 
Executing: 
line 1176: " Pike and Cmod
Executing: " Pike and Cmod
line 1177: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
Executing: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1178: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
Executing: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1179: 
Executing: 
line 1180: " Pinfo config
Executing: " Pinfo config
line 1181: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
Executing: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1182: 
Executing: 
line 1183: " Palm Resource compiler
Executing: " Palm Resource compiler
line 1184: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
Executing: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1185: 
Executing: 
line 1186: " Pine config
Executing: " Pine config
line 1187: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
Executing: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1188: 
Executing: 
line 1189: " Pipenv Pipfiles
Executing: " Pipenv Pipfiles
line 1190: au BufNewFile,BufRead Pipfile^I^I^Isetf config
Executing: au BufNewFile,BufRead Pipfile^I^I^Isetf config
line 1191: au BufNewFile,BufRead Pipfile.lock^I^Isetf json
Executing: au BufNewFile,BufRead Pipfile.lock^I^Isetf json
line 1192: 
Executing: 
line 1193: " PL/1, PL/I
Executing: " PL/1, PL/I
line 1194: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
Executing: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1195: 
Executing: 
line 1196: " PL/M (also: *.inp)
Executing: " PL/M (also: *.inp)
line 1197: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
Executing: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1198: 
Executing: 
line 1199: " PL/SQL
Executing: " PL/SQL
line 1200: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
Executing: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1201: 
Executing: 
line 1202: " PLP
Executing: " PLP
line 1203: au BufNewFile,BufRead *.plp^I^I^Isetf plp
Executing: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1204: 
Executing: 
line 1205: " PO and PO template (GNU gettext)
Executing: " PO and PO template (GNU gettext)
line 1206: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
Executing: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1207: 
Executing: 
line 1208: " Postfix main config
Executing: " Postfix main config
line 1209: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
Executing: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1210: 
Executing: 
line 1211: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
Executing: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1212: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
Executing: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1213: 
Executing: 
line 1214: " PostScript Printer Description
Executing: " PostScript Printer Description
line 1215: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
Executing: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1216: 
Executing: 
line 1217: " Povray
Executing: " Povray
line 1218: au BufNewFile,BufRead *.pov^I^I^Isetf pov
Executing: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1219: 
Executing: 
line 1220: " Povray configuration
Executing: " Povray configuration
line 1221: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
Executing: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1222: 
Executing: 
line 1223: " Povray, PHP or assembly
Executing: " Povray, PHP or assembly
line 1224: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
Executing: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1225: 
Executing: 
line 1226: " Printcap and Termcap
Executing: " Printcap and Termcap
line 1227: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
Executing: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1229: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
Executing: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1231: 
Executing: 
line 1232: " PCCTS / ANTRL
Executing: " PCCTS / ANTRL
line 1233: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
Executing: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1234: au BufNewFile,BufRead *.g^I^I^Isetf pccts
Executing: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1235: 
Executing: 
line 1236: " PPWizard
Executing: " PPWizard
line 1237: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
Executing: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1238: 
Executing: 
line 1239: " Obj 3D file format
Executing: " Obj 3D file format
line 1240: " TODO: is there a way to avoid MS-Windows Object files?
Executing: " TODO: is there a way to avoid MS-Windows Object files?
line 1241: au BufNewFile,BufRead *.obj^I^I^Isetf obj
Executing: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1242: 
Executing: 
line 1243: " Oracle Pro*C/C++
Executing: " Oracle Pro*C/C++
line 1244: au BufNewFile,BufRead *.pc^I^I^Isetf proc
Executing: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1245: 
Executing: 
line 1246: " Privoxy actions file
Executing: " Privoxy actions file
line 1247: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
Executing: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1248: 
Executing: 
line 1249: " Procmail
Executing: " Procmail
line 1250: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
Executing: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1251: 
Executing: 
line 1252: " Progress or CWEB
Executing: " Progress or CWEB
line 1253: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
Executing: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1254: 
Executing: 
line 1255: " Progress or assembly
Executing: " Progress or assembly
line 1256: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()
Executing: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()
line 1257: 
Executing: 
line 1258: " Progress or Pascal
Executing: " Progress or Pascal
line 1259: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
Executing: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1260: 
Executing: 
line 1261: " Software Distributor Product Specification File (POSIX 1387.2-1995)
Executing: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1262: au BufNewFile,BufRead *.psf^I^I^Isetf psf
Executing: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1263: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
Executing: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1267: 
Executing: 
line 1268: " Prolog
Executing: " Prolog
line 1269: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
Executing: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1270: 
Executing: 
line 1271: " Promela
Executing: " Promela
line 1272: au BufNewFile,BufRead *.pml^I^I^Isetf promela
Executing: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1273: 
Executing: 
line 1274: " Google protocol buffers
Executing: " Google protocol buffers
line 1275: au BufNewFile,BufRead *.proto^I^I^Isetf proto
Executing: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1276: 
Executing: 
line 1277: " Protocols
Executing: " Protocols
line 1278: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
Executing: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1279: 
Executing: 
line 1280: " Pyrex
Executing: " Pyrex
line 1281: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
Executing: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1282: 
Executing: 
line 1283: " Python, Python Shell Startup and Python Stub Files
Executing: " Python, Python Shell Startup and Python Stub Files
line 1284: " Quixote (Python-based web framework)
Executing: " Quixote (Python-based web framework)
line 1285: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl,*.pyi  setf python
Executing: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl,*.pyi  setf python
line 1286: 
Executing: 
line 1287: " Radiance
Executing: " Radiance
line 1288: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
Executing: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1289: 
Executing: 
line 1290: " Ratpoison config/command files
Executing: " Ratpoison config/command files
line 1291: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
Executing: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1292: 
Executing: 
line 1293: " RCS file
Executing: " RCS file
line 1294: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
Executing: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1295: 
Executing: 
line 1296: " Readline
Executing: " Readline
line 1297: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
Executing: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1298: 
Executing: 
line 1299: " Registry for MS-Windows
Executing: " Registry for MS-Windows
line 1300: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
Executing: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1302: 
Executing: 
line 1303: " Renderman Interface Bytestream
Executing: " Renderman Interface Bytestream
line 1304: au BufNewFile,BufRead *.rib^I^I^Isetf rib
Executing: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1305: 
Executing: 
line 1306: " Rexx
Executing: " Rexx
line 1307: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
Executing: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1308: 
Executing: 
line 1309: " R (Splus)
Executing: " R (Splus)
line 1310: if has("fname_case")
Executing: if has("fname_case")
line 1311:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
Executing:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1312: else
Executing: else
line 1313:   au BufNewFile,BufRead *.s^I^I^Isetf r
Executing:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1314: endif
Executing: endif
line 1315: 
Executing: 
line 1316: " R Help file
Executing: " R Help file
line 1317: if has("fname_case")
Executing: if has("fname_case")
line 1318:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
Executing:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1319: else
Executing: else
line 1320:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
Executing:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1321: endif
Executing: endif
line 1322: 
Executing: 
line 1323: " R noweb file
Executing: " R noweb file
line 1324: if has("fname_case")
Executing: if has("fname_case")
line 1325:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
Executing:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1326: else
Executing: else
line 1327:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
Executing:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1328: endif
Executing: endif
line 1329: 
Executing: 
line 1330: " R Markdown file
Executing: " R Markdown file
line 1331: if has("fname_case")
Executing: if has("fname_case")
line 1332:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
Executing:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1333: else
Executing: else
line 1334:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
Executing:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1335: endif
Executing: endif
line 1336: 
Executing: 
line 1337: " R reStructuredText file
Executing: " R reStructuredText file
line 1338: if has("fname_case")
Executing: if has("fname_case")
line 1339:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
Executing:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1340: else
Executing: else
line 1341:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
Executing:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1342: endif
Executing: endif
line 1343: 
Executing: 
line 1344: " Rexx, Rebol or R
Executing: " Rexx, Rebol or R
line 1345: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
Executing: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 1346: 
Executing: 
line 1347: " Remind
Executing: " Remind
line 1348: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
Executing: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1349: 
Executing: 
line 1350: " Resolv.conf
Executing: " Resolv.conf
line 1351: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
Executing: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1352: 
Executing: 
line 1353: " Relax NG Compact
Executing: " Relax NG Compact
line 1354: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
Executing: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1355: 
Executing: 
line 1356: " Relax NG XML
Executing: " Relax NG XML
line 1357: au BufNewFile,BufRead *.rng^I^I^Isetf rng
Executing: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1358: 
Executing: 
line 1359: " RPL/2
Executing: " RPL/2
line 1360: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
Executing: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1361: 
Executing: 
line 1362: " Robots.txt
Executing: " Robots.txt
line 1363: au BufNewFile,BufRead robots.txt^I^Isetf robots
Executing: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1364: 
Executing: 
line 1365: " Rpcgen
Executing: " Rpcgen
line 1366: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
Executing: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1367: 
Executing: 
line 1368: " reStructuredText Documentation Format
Executing: " reStructuredText Documentation Format
line 1369: au BufNewFile,BufRead *.rst^I^I^Isetf rst
Executing: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1370: 
Executing: 
line 1371: " RTF
Executing: " RTF
line 1372: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
Executing: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1373: 
Executing: 
line 1374: " Interactive Ruby shell
Executing: " Interactive Ruby shell
line 1375: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
Executing: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1376: 
Executing: 
line 1377: " Ruby
Executing: " Ruby
line 1378: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
Executing: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1379: 
Executing: 
line 1380: " RubyGems
Executing: " RubyGems
line 1381: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
Executing: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1382: 
Executing: 
line 1383: " Rust
Executing: " Rust
line 1384: au BufNewFile,BufRead *.rs^I^I^Isetf rust
Executing: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1385: 
Executing: 
line 1386: " Rackup
Executing: " Rackup
line 1387: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
Executing: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1388: 
Executing: 
line 1389: " Bundler
Executing: " Bundler
line 1390: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
Executing: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1391: 
Executing: 
line 1392: " Ruby on Rails
Executing: " Ruby on Rails
line 1393: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
Executing: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1394: 
Executing: 
line 1395: " Rantfile and Rakefile is like Ruby
Executing: " Rantfile and Rakefile is like Ruby
line 1396: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
Executing: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1397: 
Executing: 
line 1398: " S-lang (or shader language, or SmallLisp)
Executing: " S-lang (or shader language, or SmallLisp)
line 1399: au BufNewFile,BufRead *.sl^I^I^Isetf slang
Executing: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1400: 
Executing: 
line 1401: " Samba config
Executing: " Samba config
line 1402: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
Executing: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1403: 
Executing: 
line 1404: " SAS script
Executing: " SAS script
line 1405: au BufNewFile,BufRead *.sas^I^I^Isetf sas
Executing: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1406: 
Executing: 
line 1407: " Sass
Executing: " Sass
line 1408: au BufNewFile,BufRead *.sass^I^I^Isetf sass
Executing: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1409: 
Executing: 
line 1410: " Sather
Executing: " Sather
line 1411: au BufNewFile,BufRead *.sa^I^I^Isetf sather
Executing: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1412: 
Executing: 
line 1413: " Scala
Executing: " Scala
line 1414: au BufNewFile,BufRead *.scala^I^I^Isetf scala
Executing: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1415: 
Executing: 
line 1416: " SBT - Scala Build Tool
Executing: " SBT - Scala Build Tool
line 1417: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
Executing: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1418: 
Executing: 
line 1419: " Scilab
Executing: " Scilab
line 1420: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
Executing: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1421: 
Executing: 
line 1422: " SCSS
Executing: " SCSS
line 1423: au BufNewFile,BufRead *.scss^I^I^Isetf scss
Executing: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1424: 
Executing: 
line 1425: " SD: Streaming Descriptors
Executing: " SD: Streaming Descriptors
line 1426: au BufNewFile,BufRead *.sd^I^I^Isetf sd
Executing: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1427: 
Executing: 
line 1428: " SDL
Executing: " SDL
line 1429: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
Executing: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1430: 
Executing: 
line 1431: " sed
Executing: " sed
line 1432: au BufNewFile,BufRead *.sed^I^I^Isetf sed
Executing: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1433: 
Executing: 
line 1434: " Sieve (RFC 3028, 5228)
Executing: " Sieve (RFC 3028, 5228)
line 1435: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
Executing: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 1436: 
Executing: 
line 1437: " Sendmail
Executing: " Sendmail
line 1438: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
Executing: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1439: 
Executing: 
line 1440: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
Executing: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1441: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
Executing: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 1442: 
Executing: 
line 1443: " Services
Executing: " Services
line 1444: au BufNewFile,BufRead */etc/services^I^Isetf services
Executing: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1445: 
Executing: 
line 1446: " Service Location config
Executing: " Service Location config
line 1447: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
Executing: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1448: 
Executing: 
line 1449: " Service Location registration
Executing: " Service Location registration
line 1450: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
Executing: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1451: 
Executing: 
line 1452: " Service Location SPI
Executing: " Service Location SPI
line 1453: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
Executing: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1454: 
Executing: 
line 1455: " Setserial config
Executing: " Setserial config
line 1456: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
Executing: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1457: 
Executing: 
line 1458: " SGML
Executing: " SGML
line 1459: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
Executing: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1469: 
Executing: 
line 1470: " SGMLDECL
Executing: " SGMLDECL
line 1471: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
Executing: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1475: 
Executing: 
line 1476: " SGML catalog file
Executing: " SGML catalog file
line 1477: au BufNewFile,BufRead catalog^I^I^Isetf catalog
Executing: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1478: 
Executing: 
line 1479: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
Executing: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1480: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
Executing: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
line 1481: " NOTE: Patterns ending in a star are further down, these have lower priority.
Executing: " NOTE: Patterns ending in a star are further down, these have lower priority.
line 1482: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD call dist#ft#SetFileTypeSH("bash")
Executing: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD call dist#ft#SetFileTypeSH("bash")
line 1483: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
Executing: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 1484: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
Executing: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
line 1485: 
Executing: 
line 1486: 
Executing: 
line 1487: " Shell script (Arch Linux) or PHP file (Drupal)
Executing: " Shell script (Arch Linux) or PHP file (Drupal)
line 1488: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
Executing: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 1494: 
Executing: 
line 1495: " tcsh scripts (patterns ending in a star further below)
Executing: " tcsh scripts (patterns ending in a star further below)
line 1496: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
Executing: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 1497: 
Executing: 
line 1498: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
Executing: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1499: " (patterns ending in a start further below)
Executing: " (patterns ending in a start further below)
line 1500: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
Executing: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 1501: 
Executing: 
line 1502: " Z-Shell script (patterns ending in a star further below)
Executing: " Z-Shell script (patterns ending in a star further below)
line 1503: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
Executing: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1504: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
Executing: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
line 1505: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
Executing: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1506: 
Executing: 
line 1507: " Scheme
Executing: " Scheme
line 1508: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
Executing: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1509: 
Executing: 
line 1510: " Screen RC
Executing: " Screen RC
line 1511: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
Executing: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1512: 
Executing: 
line 1513: " Simula
Executing: " Simula
line 1514: au BufNewFile,BufRead *.sim^I^I^Isetf simula
Executing: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1515: 
Executing: 
line 1516: " SINDA
Executing: " SINDA
line 1517: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
Executing: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1518: 
Executing: 
line 1519: " SiSU
Executing: " SiSU
line 1520: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
Executing: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1521: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
Executing: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1522: 
Executing: 
line 1523: " SKILL
Executing: " SKILL
line 1524: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
Executing: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1525: 
Executing: 
line 1526: " SLRN
Executing: " SLRN
line 1527: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
Executing: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1528: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
Executing: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1529: 
Executing: 
line 1530: " Smalltalk (and TeX)
Executing: " Smalltalk (and TeX)
line 1531: au BufNewFile,BufRead *.st^I^I^Isetf st
Executing: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1532: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
Executing: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1540: 
Executing: 
line 1541: " Smarty templates
Executing: " Smarty templates
line 1542: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
Executing: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1543: 
Executing: 
line 1544: " SMIL or XML
Executing: " SMIL or XML
line 1545: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
Executing: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1551: 
Executing: 
line 1552: " SMIL or SNMP MIB file
Executing: " SMIL or SNMP MIB file
line 1553: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
Executing: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1559: 
Executing: 
line 1560: " SMITH
Executing: " SMITH
line 1561: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
Executing: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1562: 
Executing: 
line 1563: " Snobol4 and spitbol
Executing: " Snobol4 and spitbol
line 1564: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
Executing: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1565: 
Executing: 
line 1566: " SNMP MIB files
Executing: " SNMP MIB files
line 1567: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
Executing: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1568: 
Executing: 
line 1569: " Snort Configuration
Executing: " Snort Configuration
line 1570: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
Executing: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1571: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
Executing: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 1572: 
Executing: 
line 1573: " Spec (Linux RPM)
Executing: " Spec (Linux RPM)
line 1574: au BufNewFile,BufRead *.spec^I^I^Isetf spec
Executing: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1575: 
Executing: 
line 1576: " Speedup (AspenTech plant simulator)
Executing: " Speedup (AspenTech plant simulator)
line 1577: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
Executing: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1578: 
Executing: 
line 1579: " Slice
Executing: " Slice
line 1580: au BufNewFile,BufRead *.ice^I^I^Isetf slice
Executing: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 1581: 
Executing: 
line 1582: " Spice
Executing: " Spice
line 1583: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
Executing: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 1584: 
Executing: 
line 1585: " Spyce
Executing: " Spyce
line 1586: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
Executing: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 1587: 
Executing: 
line 1588: " Squid
Executing: " Squid
line 1589: au BufNewFile,BufRead squid.conf^I^Isetf squid
Executing: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 1590: 
Executing: 
line 1591: " SQL for Oracle Designer
Executing: " SQL for Oracle Designer
line 1592: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
Executing: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 1593: 
Executing: 
line 1594: " SQL
Executing: " SQL
line 1595: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
Executing: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 1596: 
Executing: 
line 1597: " SQLJ
Executing: " SQLJ
line 1598: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
Executing: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 1599: 
Executing: 
line 1600: " SQR
Executing: " SQR
line 1601: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
Executing: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 1602: 
Executing: 
line 1603: " OpenSSH configuration
Executing: " OpenSSH configuration
line 1604: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
Executing: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 1605: 
Executing: 
line 1606: " OpenSSH server configuration
Executing: " OpenSSH server configuration
line 1607: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
Executing: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 1608: 
Executing: 
line 1609: " Stata
Executing: " Stata
line 1610: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
Executing: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 1611: " Also *.class, but not when it's a Java bytecode file
Executing: " Also *.class, but not when it's a Java bytecode file
line 1612: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
Executing: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 1614: 
Executing: 
line 1615: " SMCL
Executing: " SMCL
line 1616: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
Executing: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 1617: 
Executing: 
line 1618: " Stored Procedures
Executing: " Stored Procedures
line 1619: au BufNewFile,BufRead *.stp^I^I^Isetf stp
Executing: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 1620: 
Executing: 
line 1621: " Standard ML
Executing: " Standard ML
line 1622: au BufNewFile,BufRead *.sml^I^I^Isetf sml
Executing: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 1623: 
Executing: 
line 1624: " Sratus VOS command macro
Executing: " Sratus VOS command macro
line 1625: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
Executing: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 1626: 
Executing: 
line 1627: " Sysctl
Executing: " Sysctl
line 1628: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
Executing: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 1629: 
Executing: 
line 1630: " Systemd unit files
Executing: " Systemd unit files
line 1631: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
Executing: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 1632: " Systemd overrides
Executing: " Systemd overrides
line 1633: au BufNewFile,BufRead /etc/systemd/system/*.d/*.conf^Isetf systemd
Executing: au BufNewFile,BufRead /etc/systemd/system/*.d/*.conf^Isetf systemd
line 1634: " Systemd temp files
Executing: " Systemd temp files
line 1635: au BufNewFile,BufRead /etc/systemd/system/*.d/.#*^Isetf systemd
Executing: au BufNewFile,BufRead /etc/systemd/system/*.d/.#*^Isetf systemd
line 1636: 
Executing: 
line 1637: " Synopsys Design Constraints
Executing: " Synopsys Design Constraints
line 1638: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
Executing: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 1639: 
Executing: 
line 1640: " Sudoers
Executing: " Sudoers
line 1641: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
Executing: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 1642: 
Executing: 
line 1643: " SVG (Scalable Vector Graphics)
Executing: " SVG (Scalable Vector Graphics)
line 1644: au BufNewFile,BufRead *.svg^I^I^Isetf svg
Executing: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 1645: 
Executing: 
line 1646: " Tads (or Nroff or Perl test file)
Executing: " Tads (or Nroff or Perl test file)
line 1647: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
Executing: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 1649: 
Executing: 
line 1650: " Tags
Executing: " Tags
line 1651: au BufNewFile,BufRead tags^I^I^Isetf tags
Executing: au BufNewFile,BufRead tags^I^I^Isetf tags
line 1652: 
Executing: 
line 1653: " TAK
Executing: " TAK
line 1654: au BufNewFile,BufRead *.tak^I^I^Isetf tak
Executing: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 1655: 
Executing: 
line 1656: " Task
Executing: " Task
line 1657: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
Executing: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 1658: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
Executing: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 1659: 
Executing: 
line 1660: " Tcl (JACL too)
Executing: " Tcl (JACL too)
line 1661: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
Executing: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 1662: 
Executing: 
line 1663: " TealInfo
Executing: " TealInfo
line 1664: au BufNewFile,BufRead *.tli^I^I^Isetf tli
Executing: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 1665: 
Executing: 
line 1666: " Telix Salt
Executing: " Telix Salt
line 1667: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
Executing: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 1668: 
Executing: 
line 1669: " Tera Term Language
Executing: " Tera Term Language
line 1670: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
Executing: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 1671: 
Executing: 
line 1672: " Terminfo
Executing: " Terminfo
line 1673: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
Executing: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 1674: 
Executing: 
line 1675: " TeX
Executing: " TeX
line 1676: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
Executing: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 1677: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
Executing: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 1678: 
Executing: 
line 1679: " ConTeXt
Executing: " ConTeXt
line 1680: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
Executing: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
line 1681: 
Executing: 
line 1682: " Texinfo
Executing: " Texinfo
line 1683: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
Executing: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 1684: 
Executing: 
line 1685: " TeX configuration
Executing: " TeX configuration
line 1686: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
Executing: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 1687: 
Executing: 
line 1688: " Tidy config
Executing: " Tidy config
line 1689: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
Executing: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 1690: 
Executing: 
line 1691: " TF mud client
Executing: " TF mud client
line 1692: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
Executing: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 1693: 
Executing: 
line 1694: " tmux configuration
Executing: " tmux configuration
line 1695: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
Executing: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 1696: 
Executing: 
line 1697: " TPP - Text Presentation Program
Executing: " TPP - Text Presentation Program
line 1698: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
Executing: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 1699: 
Executing: 
line 1700: " Treetop
Executing: " Treetop
line 1701: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
Executing: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 1702: 
Executing: 
line 1703: " Trustees
Executing: " Trustees
line 1704: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
Executing: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 1705: 
Executing: 
line 1706: " TSS - Geometry
Executing: " TSS - Geometry
line 1707: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
Executing: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 1708: 
Executing: 
line 1709: " TSS - Optics
Executing: " TSS - Optics
line 1710: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
Executing: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 1711: 
Executing: 
line 1712: " TSS - Command Line (temporary)
Executing: " TSS - Command Line (temporary)
line 1713: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
Executing: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 1714: 
Executing: 
line 1715: " TWIG files
Executing: " TWIG files
line 1716: au BufNewFile,BufReadPost *.twig^I^Isetf twig
Executing: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 1717: 
Executing: 
line 1718: " Typescript
Executing: " Typescript
line 1719: au BufNewFile,BufReadPost *.ts^I^I^Isetf typescript
Executing: au BufNewFile,BufReadPost *.ts^I^I^Isetf typescript
line 1720: 
Executing: 
line 1721: " TypeScript with React
Executing: " TypeScript with React
line 1722: au BufNewFile,BufRead *.tsx^I^I^Isetf typescriptreact
Executing: au BufNewFile,BufRead *.tsx^I^I^Isetf typescriptreact
line 1723: 
Executing: 
line 1724: " Motif UIT/UIL files
Executing: " Motif UIT/UIL files
line 1725: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
Executing: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 1726: 
Executing: 
line 1727: " Udev conf
Executing: " Udev conf
line 1728: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
Executing: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 1729: 
Executing: 
line 1730: " Udev permissions
Executing: " Udev permissions
line 1731: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
Executing: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 1732: "
Executing: "
line 1733: " Udev symlinks config
Executing: " Udev symlinks config
line 1734: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
Executing: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 1735: 
Executing: 
line 1736: " UnrealScript
Executing: " UnrealScript
line 1737: au BufNewFile,BufRead *.uc^I^I^Isetf uc
Executing: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 1738: 
Executing: 
line 1739: " Updatedb
Executing: " Updatedb
line 1740: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
Executing: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 1741: 
Executing: 
line 1742: " Upstart (init(8)) config files
Executing: " Upstart (init(8)) config files
line 1743: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
Executing: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 1744: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
Executing: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 1745: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
Executing: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 1746: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
Executing: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 1747: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
Executing: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 1748: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
Executing: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 1749: 
Executing: 
line 1750: " Vera
Executing: " Vera
line 1751: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
Executing: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 1752: 
Executing: 
line 1753: " Verilog HDL
Executing: " Verilog HDL
line 1754: au BufNewFile,BufRead *.v^I^I^Isetf verilog
Executing: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 1755: 
Executing: 
line 1756: " Verilog-AMS HDL
Executing: " Verilog-AMS HDL
line 1757: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
Executing: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 1758: 
Executing: 
line 1759: " SystemVerilog
Executing: " SystemVerilog
line 1760: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
Executing: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 1761: 
Executing: 
line 1762: " VHDL
Executing: " VHDL
line 1763: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
Executing: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 1764: 
Executing: 
line 1765: " Vim script
Executing: " Vim script
line 1766: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
Executing: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 1767: 
Executing: 
line 1768: " Viminfo file
Executing: " Viminfo file
line 1769: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
Executing: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 1770: 
Executing: 
line 1771: " Virata Config Script File or Drupal module
Executing: " Virata Config Script File or Drupal module
line 1772: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
Executing: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 1778: 
Executing: 
line 1779: " Visual Basic (also uses *.bas) or FORM
Executing: " Visual Basic (also uses *.bas) or FORM
line 1780: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")
Executing: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")
line 1781: 
Executing: 
line 1782: " SaxBasic is close to Visual Basic
Executing: " SaxBasic is close to Visual Basic
line 1783: au BufNewFile,BufRead *.sba^I^I^Isetf vb
Executing: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 1784: 
Executing: 
line 1785: " Vgrindefs file
Executing: " Vgrindefs file
line 1786: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
Executing: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 1787: 
Executing: 
line 1788: " VRML V1.0c
Executing: " VRML V1.0c
line 1789: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
Executing: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 1790: 
Executing: 
line 1791: " Vroom (vim testing and executable documentation)
Executing: " Vroom (vim testing and executable documentation)
line 1792: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
Executing: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 1793: 
Executing: 
line 1794: " Vue.js Single File Component
Executing: " Vue.js Single File Component
line 1795: au BufNewFile,BufRead *.vue^I^I^Isetf vue
Executing: au BufNewFile,BufRead *.vue^I^I^Isetf vue
line 1796: 
Executing: 
line 1797: " WebAssembly
Executing: " WebAssembly
line 1798: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast
Executing: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast
line 1799: 
Executing: 
line 1800: " Webmacro
Executing: " Webmacro
line 1801: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
Executing: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 1802: 
Executing: 
line 1803: " Wget config
Executing: " Wget config
line 1804: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
Executing: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 1805: 
Executing: 
line 1806: " Website MetaLanguage
Executing: " Website MetaLanguage
line 1807: au BufNewFile,BufRead *.wml^I^I^Isetf wml
Executing: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 1808: 
Executing: 
line 1809: " Winbatch
Executing: " Winbatch
line 1810: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
Executing: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 1811: 
Executing: 
line 1812: " WSML
Executing: " WSML
line 1813: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
Executing: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 1814: 
Executing: 
line 1815: " WPL
Executing: " WPL
line 1816: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 1817: 
Executing: 
line 1818: " WvDial
Executing: " WvDial
line 1819: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
Executing: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 1820: 
Executing: 
line 1821: " CVS RC file
Executing: " CVS RC file
line 1822: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
Executing: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 1823: 
Executing: 
line 1824: " CVS commit file
Executing: " CVS commit file
line 1825: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
Executing: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 1826: 
Executing: 
line 1827: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
Executing: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 1828: " lines in a WEB file).
Executing: " lines in a WEB file).
line 1829: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
Executing: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 1835: 
Executing: 
line 1836: " Windows Scripting Host and Windows Script Component
Executing: " Windows Scripting Host and Windows Script Component
line 1837: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
Executing: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 1838: 
Executing: 
line 1839: " XHTML
Executing: " XHTML
line 1840: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
Executing: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 1841: 
Executing: 
line 1842: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
Executing: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 1843: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
Executing: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 1849: au BufEnter *.xpm2^I^I^I^Isetf xpm2
Executing: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 1850: 
Executing: 
line 1851: " XFree86 config
Executing: " XFree86 config
line 1852: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
Executing: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 1857: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
Executing: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1860: 
Executing: 
line 1861: " Xorg config
Executing: " Xorg config
line 1862: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
Executing: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1863: 
Executing: 
line 1864: " Xinetd conf
Executing: " Xinetd conf
line 1865: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
Executing: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 1866: 
Executing: 
line 1867: " XS Perl extension interface language
Executing: " XS Perl extension interface language
line 1868: au BufNewFile,BufRead *.xs^I^I^Isetf xs
Executing: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 1869: 
Executing: 
line 1870: " X resources file
Executing: " X resources file
line 1871: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
Executing: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 1872: 
Executing: 
line 1873: " Xmath
Executing: " Xmath
line 1874: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
Executing: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 1875: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
Executing: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 1877: 
Executing: 
line 1878: " XML  specific variants: docbk and xbl
Executing: " XML  specific variants: docbk and xbl
line 1879: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
Executing: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 1880: 
Executing: 
line 1881: " XMI (holding UML models) is also XML
Executing: " XMI (holding UML models) is also XML
line 1882: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 1883: 
Executing: 
line 1884: " CSPROJ files are Visual Studio.NET's XML-based project config files
Executing: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 1885: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
Executing: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 1886: 
Executing: 
line 1887: " Qt Linguist translation source and Qt User Interface Files are XML
Executing: " Qt Linguist translation source and Qt User Interface Files are XML
line 1888: " However, for .ts Typescript is more common.
Executing: " However, for .ts Typescript is more common.
line 1889: au BufNewFile,BufRead *.ui^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.ui^I^I^Isetf xml
line 1890: 
Executing: 
line 1891: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
Executing: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 1892: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 1893: 
Executing: 
line 1894: " Xdg menus
Executing: " Xdg menus
line 1895: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
Executing: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 1896: 
Executing: 
line 1897: " ATI graphics driver configuration
Executing: " ATI graphics driver configuration
line 1898: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
Executing: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 1899: 
Executing: 
line 1900: " Web Services Description Language (WSDL)
Executing: " Web Services Description Language (WSDL)
line 1901: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 1902: 
Executing: 
line 1903: " XLIFF (XML Localisation Interchange File Format) is also XML
Executing: " XLIFF (XML Localisation Interchange File Format) is also XML
line 1904: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 1905: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 1906: 
Executing: 
line 1907: " XML User Interface Language
Executing: " XML User Interface Language
line 1908: au BufNewFile,BufRead *.xul^I^I^Isetf xml
Executing: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 1909: 
Executing: 
line 1910: " X11 xmodmap (also see below)
Executing: " X11 xmodmap (also see below)
line 1911: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
Executing: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 1912: 
Executing: 
line 1913: " Xquery
Executing: " Xquery
line 1914: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
Executing: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 1915: 
Executing: 
line 1916: " XSD
Executing: " XSD
line 1917: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
Executing: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 1918: 
Executing: 
line 1919: " Xslt
Executing: " Xslt
line 1920: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
Executing: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 1921: 
Executing: 
line 1922: " Yacc
Executing: " Yacc
line 1923: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
Executing: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 1924: 
Executing: 
line 1925: " Yacc or racc
Executing: " Yacc or racc
line 1926: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
Executing: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 1927: 
Executing: 
line 1928: " Yaml
Executing: " Yaml
line 1929: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
Executing: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 1930: 
Executing: 
line 1931: " Raml
Executing: " Raml
line 1932: au BufNewFile,BufRead *.raml^I^I^Isetf raml
Executing: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 1933: 
Executing: 
line 1934: " yum conf (close enough to dosini)
Executing: " yum conf (close enough to dosini)
line 1935: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
Executing: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 1936: 
Executing: 
line 1937: " Zimbu
Executing: " Zimbu
line 1938: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
Executing: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 1939: " Zimbu Templates
Executing: " Zimbu Templates
line 1940: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
Executing: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 1941: 
Executing: 
line 1942: " Zope
Executing: " Zope
line 1943: "   dtml (zope dynamic template markup language), pt (zope page template),
Executing: "   dtml (zope dynamic template markup language), pt (zope page template),
line 1944: "   cpt (zope form controller page template)
Executing: "   cpt (zope form controller page template)
line 1945: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
Executing: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 1946: "   zsql (zope sql method)
Executing: "   zsql (zope sql method)
line 1947: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
Executing: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 1948: 
Executing: 
line 1949: " Z80 assembler asz80
Executing: " Z80 assembler asz80
line 1950: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
Executing: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 1951: 
Executing: 
line 1952: augroup END
Executing: augroup END
line 1953: 
Executing: 
line 1954: 
Executing: 
line 1955: " Source the user-specified filetype file, for backwards compatibility with
Executing: " Source the user-specified filetype file, for backwards compatibility with
line 1956: " Vim 5.x.
Executing: " Vim 5.x.
line 1957: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
Executing: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 1958:   execute "source " . myfiletypefile
Executing:   execute "source " . myfiletypefile
line 1959: endif
Executing: endif
line 1960: 
Executing: 
line 1961: 
Executing: 
line 1962: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
Executing: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 1963: " when there are no matching file name extensions.
Executing: " when there are no matching file name extensions.
line 1964: " Don't do this for compressed files.
Executing: " Don't do this for compressed files.
line 1965: augroup filetypedetect
Executing: augroup filetypedetect
line 1966: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 1969: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
Executing: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 1970: 
Executing: 
line 1971: 
Executing: 
line 1972: " Extra checks for when no filetype has been detected now.  Mostly used for
Executing: " Extra checks for when no filetype has been detected now.  Mostly used for
line 1973: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
Executing: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 1974: " script file.
Executing: " script file.
line 1975: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
Executing: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 1976: " like are used.
Executing: " like are used.
line 1977: 
Executing: 
line 1978: " More Apache style config files
Executing: " More Apache style config files
line 1979: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
Executing: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 1980: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')
Executing: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')
line 1981: 
Executing: 
line 1982: " More Apache config files
Executing: " More Apache config files
line 1983: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
Executing: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 1984: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
Executing: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 1985: 
Executing: 
line 1986: " Asterisk config file
Executing: " Asterisk config file
line 1987: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
Executing: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 1988: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
Executing: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 1989: 
Executing: 
line 1990: " Bazaar version control
Executing: " Bazaar version control
line 1991: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
Executing: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 1992: 
Executing: 
line 1993: " Bazel build file
Executing: " Bazel build file
line 1994: if !has("fname_case")
Executing: if !has("fname_case")
line 1995:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
Executing:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
line 1996: endif
Executing: endif
line 1997: 
Executing: 
line 1998: " BIND zone
Executing: " BIND zone
line 1999: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
Executing: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2000: 
Executing: 
line 2001: " Calendar
Executing: " Calendar
line 2002: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
Executing: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2005: 
Executing: 
line 2006: " Changelog
Executing: " Changelog
line 2007: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
Executing: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2013: 
Executing: 
line 2014: " Crontab
Executing: " Crontab
line 2015: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
Executing: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2016: 
Executing: 
line 2017: " dnsmasq(8) configuration
Executing: " dnsmasq(8) configuration
line 2018: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
Executing: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2019: 
Executing: 
line 2020: " Dracula
Executing: " Dracula
line 2021: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
Executing: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2022: 
Executing: 
line 2023: " Fvwm
Executing: " Fvwm
line 2024: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
Executing: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2025: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
Executing: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2027: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
Executing: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2033: 
Executing: 
line 2034: " Gedcom
Executing: " Gedcom
line 2035: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
Executing: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2036: 
Executing: 
line 2037: " Git
Executing: " Git
line 2038: au BufNewFile,BufRead */.gitconfig.d/*,/etc/gitconfig.d/* ^Icall s:StarSetf('gitconfig')
Executing: au BufNewFile,BufRead */.gitconfig.d/*,/etc/gitconfig.d/* ^Icall s:StarSetf('gitconfig')
line 2039: 
Executing: 
line 2040: " Gitolite
Executing: " Gitolite
line 2041: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
Executing: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 2042: 
Executing: 
line 2043: " GTK RC
Executing: " GTK RC
line 2044: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
Executing: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2045: 
Executing: 
line 2046: " Jam
Executing: " Jam
line 2047: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
Executing: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2048: 
Executing: 
line 2049: " Jargon
Executing: " Jargon
line 2050: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
Executing: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2054: 
Executing: 
line 2055: " Java Properties resource file (note: doesn't catch font.properties.pl)
Executing: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 2056: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
Executing: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 2057: 
Executing: 
line 2058: " Kconfig
Executing: " Kconfig
line 2059: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
Executing: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2060: 
Executing: 
line 2061: " Lilo: Linux loader
Executing: " Lilo: Linux loader
line 2062: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
Executing: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2063: 
Executing: 
line 2064: " Logcheck
Executing: " Logcheck
line 2065: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
Executing: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2066: 
Executing: 
line 2067: " Makefile
Executing: " Makefile
line 2068: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
Executing: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2069: 
Executing: 
line 2070: " Ruby Makefile
Executing: " Ruby Makefile
line 2071: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
Executing: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2072: 
Executing: 
line 2073: " Mail (also matches muttrc.vim, so this is below the other checks)
Executing: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2074: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
Executing: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2075: 
Executing: 
line 2076: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
Executing: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2077: 
Executing: 
line 2078: " Modconf
Executing: " Modconf
line 2079: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
Executing: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2083: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
Executing: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2084: 
Executing: 
line 2085: " Mutt setup file
Executing: " Mutt setup file
line 2086: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
Executing: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2087: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
Executing: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2088: 
Executing: 
line 2089: " Neomutt setup file
Executing: " Neomutt setup file
line 2090: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
Executing: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 2091: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
Executing: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 2092: 
Executing: 
line 2093: " Nroff macros
Executing: " Nroff macros
line 2094: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
Executing: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2095: 
Executing: 
line 2096: " OpenBSD hostname.if
Executing: " OpenBSD hostname.if
line 2097: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
Executing: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
line 2098: 
Executing: 
line 2099: " Pam conf
Executing: " Pam conf
line 2100: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
Executing: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2101: 
Executing: 
line 2102: " Printcap and Termcap
Executing: " Printcap and Termcap
line 2103: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
Executing: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2107: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
Executing: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2111: 
Executing: 
line 2112: " ReDIF
Executing: " ReDIF
line 2113: " Only used when the .rdf file was not detected to be XML.
Executing: " Only used when the .rdf file was not detected to be XML.
line 2114: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
Executing: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 2115: 
Executing: 
line 2116: " Remind
Executing: " Remind
line 2117: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
Executing: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2118: 
Executing: 
line 2119: " SGML catalog file
Executing: " SGML catalog file
line 2120: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
Executing: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 2121: 
Executing: 
line 2122: " Shell scripts ending in a star
Executing: " Shell scripts ending in a star
line 2123: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
Executing: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
line 2124: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
Executing: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
line 2125: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
Executing: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
line 2126: 
Executing: 
line 2127: " tcsh scripts ending in a star
Executing: " tcsh scripts ending in a star
line 2128: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")
Executing: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")
line 2129: 
Executing: 
line 2130: " csh scripts ending in a star
Executing: " csh scripts ending in a star
line 2131: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
Executing: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
line 2132: 
Executing: 
line 2133: " VHDL
Executing: " VHDL
line 2134: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
Executing: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2135: 
Executing: 
line 2136: " Vim script
Executing: " Vim script
line 2137: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
Executing: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2138: 
Executing: 
line 2139: " Subversion commit file
Executing: " Subversion commit file
line 2140: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
Executing: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2141: 
Executing: 
line 2142: " X resources file
Executing: " X resources file
line 2143: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
Executing: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2144: 
Executing: 
line 2145: " XFree86 config
Executing: " XFree86 config
line 2146: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
Executing: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2148: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
Executing: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2153: 
Executing: 
line 2154: " X11 xmodmap
Executing: " X11 xmodmap
line 2155: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
Executing: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2156: 
Executing: 
line 2157: " Xinetd conf
Executing: " Xinetd conf
line 2158: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
Executing: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2159: 
Executing: 
line 2160: " yum conf (close enough to dosini)
Executing: " yum conf (close enough to dosini)
line 2161: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
Executing: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2162: 
Executing: 
line 2163: " Z-Shell script ending in a star
Executing: " Z-Shell script ending in a star
line 2164: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
Executing: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 2165: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
Executing: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2166: 
Executing: 
line 2167: 
Executing: 
line 2168: " Plain text files, needs to be far down to not override others.  This avoids
Executing: " Plain text files, needs to be far down to not override others.  This avoids
line 2169: " the "conf" type being used if there is a line starting with '#'.
Executing: " the "conf" type being used if there is a line starting with '#'.
line 2170: au BufNewFile,BufRead *.text,README^I^Isetf text
Executing: au BufNewFile,BufRead *.text,README^I^Isetf text
line 2171: 
Executing: 
line 2172: " Help files match *.txt but should have a last line that is a modeline.
Executing: " Help files match *.txt but should have a last line that is a modeline.
line 2173: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
Executing: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2177: 
Executing: 
line 2178: 
Executing: 
line 2179: " Use the filetype detect plugins.  They may overrule any of the previously
Executing: " Use the filetype detect plugins.  They may overrule any of the previously
line 2180: " detected filetypes.
Executing: " detected filetypes.
line 2181: runtime! ftdetect/*.vim
Executing: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/ftdetect/*.vim"
Searching for "/etc/vim/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/share/vim/vim81/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/etc/vim/after/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/after/ftdetect/*.vim"
Searching for "/home/kangaroo/.vim/after/ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2182: 
Executing: 
line 2183: " NOTE: The above command could have ended the filetypedetect autocmd group
Executing: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2184: " and started another one. Let's make sure it has ended to get to a consistent
Executing: " and started another one. Let's make sure it has ended to get to a consistent
line 2185: " state.
Executing: " state.
line 2186: augroup END
Executing: augroup END
line 2187: 
Executing: 
line 2188: " Generic configuration file. Use FALLBACK, it's just guessing!
Executing: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2189: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
Executing: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2195: 
Executing: 
line 2196: 
Executing: 
line 2197: " If the GUI is already running, may still need to install the Syntax menu.
Executing: " If the GUI is already running, may still need to install the Syntax menu.
line 2198: " Don't do it when the 'M' flag is included in 'guioptions'.
Executing: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2199: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
Executing: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2201:   source <sfile>:p:h/menu.vim
Executing:   source <sfile>:p:h/menu.vim
line 2202: endif
Executing: endif
line 2203: 
Executing: 
line 2204: " Function called for testing all functions defined here.  These are
Executing: " Function called for testing all functions defined here.  These are
line 2205: " script-local, thus need to be executed here.
Executing: " script-local, thus need to be executed here.
line 2206: " Returns a string with error messages (hopefully empty).
Executing: " Returns a string with error messages (hopefully empty).
line 2207: func! TestFiletypeFuncs(testlist)
Executing: func! TestFiletypeFuncs(testlist)
line 2218: 
Executing: 
line 2219: " Restore 'cpoptions'
Executing: " Restore 'cpoptions'
line 2220: let &cpo = s:cpo_save
Executing: let &cpo = s:cpo_save
line 2221: unlet s:cpo_save
Executing: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/etc/vim/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/kangaroo/.vim/after/filetype.vim"
line 26:   let s:did_ft = 0
Executing:   let s:did_ft = 0
line 27: endif
Executing: endif
line 28: 
Executing: 
line 29: " Set up the connection between FileType and Syntax autocommands.
Executing: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
Executing: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
Executing: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
Executing:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
Executing: augroup END
line 34: 
Executing: 
line 35: 
Executing: 
line 36: " Execute the syntax autocommands for the each buffer.
Executing: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
Executing: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
Executing: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
Executing: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
Executing: doautoall syntaxset FileType
line 41: if !s:did_ft
Executing: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
Executing:   doautoall filetypedetect BufRead
line 43: endif
Executing: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in /usr/share/vim/vimrc
line 12: endif
Executing: endif
line 13: 
Executing: 
line 14: "tabs
Executing: "tabs
line 15: set tabstop=4 softtabstop=4
Executing: set tabstop=4 softtabstop=4
line 16: set shiftwidth=4
Executing: set shiftwidth=4
line 17: set expandtab
Executing: set expandtab
line 18: set smartindent
Executing: set smartindent
line 19: 
Executing: 
line 20: no errorbells
Executing: no errorbells

                        No mapping found
line 21: set noswapfile
Executing: set noswapfile
line 22: set exrc
Executing: set exrc
line 23: 
Executing: 
line 24: "linestuff
Executing: "linestuff
line 25: set relativenumber
Executing: set relativenumber
line 26: set nu
Executing: set nu
line 27: set nowrap
Executing: set nowrap
line 28: set scrolloff=8
Executing: set scrolloff=8
line 29: set colorcolumn=80
Executing: set colorcolumn=80
line 30: highlight ColorColumn ctermbg=0 guibg=white
Executing: highlight ColorColumn ctermbg=0 guibg=white
line 31: 
Executing: 
line 32: "search
Executing: "search
line 33: set incsearch
Executing: set incsearch
line 34: set nohlsearch
Executing: set nohlsearch
line 35: 
Executing: 
finished sourcing $VIM/vimrc
chdir(/home/kangaroo)
fchdir() to previous dir
could not source "$HOME/.vimrc"
chdir(/home/kangaroo/.vim)
fchdir() to previous dir
could not source "~/.vim/vimrc"
chdir(/home/kangaroo)
fchdir() to previous dir
could not source "$HOME/.exrc"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
sourcing "$VIMRUNTIME/defaults.vim"
line 1: " The default vimrc file.
Executing: " The default vimrc file.
line 2: "
Executing: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2019 Oct 27
Executing: " Last change:^I2019 Oct 27
line 5: "
Executing: "
line 6: " This is loaded if no vimrc file was found.
Executing: " This is loaded if no vimrc file was found.
line 7: " Except when Vim is run with "-u NONE" or "-C".
Executing: " Except when Vim is run with "-u NONE" or "-C".
line 8: " Individual settings can be reverted with ":set option&".
Executing: " Individual settings can be reverted with ":set option&".
line 9: " Other commands can be reverted as mentioned below.
Executing: " Other commands can be reverted as mentioned below.
line 10: 
Executing: 
line 11: " When started as "evim", evim.vim will already have done these settings.
Executing: " When started as "evim", evim.vim will already have done these settings.
line 12: if v:progname =~? "evim"
Executing: if v:progname =~? "evim"
line 13:   finish
Executing:   finish
line 14: endif
Executing: endif
line 15: 
Executing: 
line 16: " Bail out if something that ran earlier, e.g. a system wide vimrc, does not
Executing: " Bail out if something that ran earlier, e.g. a system wide vimrc, does not
line 17: " want Vim to use these default values.
Executing: " want Vim to use these default values.
line 18: if exists('skip_defaults_vim')
Executing: if exists('skip_defaults_vim')
line 19:   finish
Executing:   finish
line 20: endif
Executing: endif
line 21: 
Executing: 
line 22: " Use Vim settings, rather than Vi settings (much better!).
Executing: " Use Vim settings, rather than Vi settings (much better!).
line 23: " This must be first, because it changes other options as a side effect.
Executing: " This must be first, because it changes other options as a side effect.
line 24: " Avoid side effects when it was already reset.
Executing: " Avoid side effects when it was already reset.
line 25: if &compatible
Executing: if &compatible
line 26:   set nocompatible
Executing:   set nocompatible
line 27: endif
Executing: endif
line 28: 
Executing: 
line 29: " When the +eval feature is missing, the set command above will be skipped.
Executing: " When the +eval feature is missing, the set command above will be skipped.
line 30: " Use a trick to reset compatible only when the +eval feature is missing.
Executing: " Use a trick to reset compatible only when the +eval feature is missing.
line 31: silent! while 0
Executing: silent! while 0
line 32:   set nocompatible
Executing:   set nocompatible
line 33: silent! endwhile
Executing: silent! endwhile
line 34: 
Executing: 
line 35: " Allow backspacing over everything in insert mode.
Executing: " Allow backspacing over everything in insert mode.
line 36: set backspace=indent,eol,start
Executing: set backspace=indent,eol,start
line 37: 
Executing: 
line 38: set history=200^I^I" keep 200 lines of command line history
Executing: set history=200^I^I" keep 200 lines of command line history
line 39: set ruler^I^I" show the cursor position all the time
Executing: set ruler^I^I" show the cursor position all the time
line 40: set showcmd^I^I" display incomplete commands
Executing: set showcmd^I^I" display incomplete commands
line 41: set wildmenu^I^I" display completion matches in a status line
Executing: set wildmenu^I^I" display completion matches in a status line
line 42: 
Executing: 
line 43: set ttimeout^I^I" time out for key codes
Executing: set ttimeout^I^I" time out for key codes
line 44: set ttimeoutlen=100^I" wait up to 100ms after Esc for special key
Executing: set ttimeoutlen=100^I" wait up to 100ms after Esc for special key
line 45: 
Executing: 
line 46: " Show @@@ in the last line if it is truncated.
Executing: " Show @@@ in the last line if it is truncated.
line 47: set display=truncate
Executing: set display=truncate
line 48: 
Executing: 
line 49: " Show a few lines of context around the cursor.  Note that this makes the
Executing: " Show a few lines of context around the cursor.  Note that this makes the
line 50: " text scroll if you mouse-click near the start or end of the window.
Executing: " text scroll if you mouse-click near the start or end of the window.
line 51: set scrolloff=5
Executing: set scrolloff=5
line 52: 
Executing: 
line 53: " Do incremental searching when it's possible to timeout.
Executing: " Do incremental searching when it's possible to timeout.
line 54: if has('reltime')
Executing: if has('reltime')
line 55:   set incsearch
Executing:   set incsearch
line 56: endif
Executing: endif
line 57: 
Executing: 
line 58: " Do not recognize octal numbers for Ctrl-A and Ctrl-X, most users find it
Executing: " Do not recognize octal numbers for Ctrl-A and Ctrl-X, most users find it
line 59: " confusing.
Executing: " confusing.
line 60: set nrformats-=octal
Executing: set nrformats-=octal
line 61: 
Executing: 
line 62: " For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries.
Executing: " For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries.
line 63: if has('win32')
Executing: if has('win32')
line 64:   set guioptions-=t
Executing:   set guioptions-=t
line 65: endif
Executing: endif
line 66: 
Executing: 
line 67: " Don't use Ex mode, use Q for formatting.
Executing: " Don't use Ex mode, use Q for formatting.
line 68: " Revert with ":unmap Q".
Executing: " Revert with ":unmap Q".
line 69: map Q gq
Executing: map Q gq
line 70: 
Executing: 
line 71: " CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
Executing: " CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
line 72: " so that you can undo CTRL-U after inserting a line break.
Executing: " so that you can undo CTRL-U after inserting a line break.
line 73: " Revert with ":iunmap <C-U>".
Executing: " Revert with ":iunmap <C-U>".
line 74: inoremap <C-U> <C-G>u<C-U>
Executing: inoremap <C-U> <C-G>u<C-U>
line 75: 
Executing: 
line 76: " Switch syntax highlighting on when the terminal has colors or when using the
Executing: " Switch syntax highlighting on when the terminal has colors or when using the
line 77: " GUI (which always has colors).
Executing: " GUI (which always has colors).
line 78: if &t_Co > 2 || has("gui_running")
Executing: if &t_Co > 2 || has("gui_running")
line 79:   " Revert with ":syntax off".
Executing:   " Revert with ":syntax off".
line 80:   syntax on
Executing:   syntax on
line 80: so $VIMRUNTIME/syntax/syntax.vim
Executing: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 80: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
Executing: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
Executing: " Last Change:^I2001 Sep 04
line 4: 
Executing: 
line 5: " This file is used for ":syntax on".
Executing: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
Executing: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
Executing: 
line 8: if !has("syntax")
Executing: if !has("syntax")
line 9:   finish
Executing:   finish
line 10: endif
Executing: endif
line 11: 
Executing: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
Executing: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
Executing: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
Executing: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
Executing:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/nosyntax.vim"
line 1: " Vim syntax support file
Executing: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2006 Apr 16
Executing: " Last Change:^I2006 Apr 16
line 4: 
Executing: 
line 5: " This file is used for ":syntax off".
Executing: " This file is used for ":syntax off".
line 6: " It removes the autocommands and stops highlighting for all buffers.
Executing: " It removes the autocommands and stops highlighting for all buffers.
line 7: 
Executing: 
line 8: if !has("syntax")
Executing: if !has("syntax")
line 9:   finish
Executing:   finish
line 10: endif
Executing: endif
line 11: 
Executing: 
line 12: " Remove all autocommands for the Syntax event.  This also avoids that
Executing: " Remove all autocommands for the Syntax event.  This also avoids that
line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
Executing: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 14: au! Syntax
Executing: au! Syntax
line 15: 
Executing: 
line 16: " remove all syntax autocommands and remove the syntax for each buffer
Executing: " remove all syntax autocommands and remove the syntax for each buffer
line 17: augroup syntaxset
Executing: augroup syntaxset
line 18:   au!
Executing:   au!
line 19:   au BufEnter * syn clear
Executing:   au BufEnter * syn clear
line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
Executing:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 21:   doautoall syntaxset BufEnter *
Executing:   doautoall syntaxset BufEnter *
line 22:   au!
Executing:   au!
line 23: augroup END
Executing: augroup END
line 24: 
Executing: 
line 25: if exists("syntax_on")
Executing: if exists("syntax_on")
line 26:   unlet syntax_on
Executing:   unlet syntax_on
line 27: endif
Executing: endif
line 28: if exists("syntax_manual")
Executing: if exists("syntax_manual")
line 29:   unlet syntax_manual
Executing:   unlet syntax_manual
line 30: endif
Executing: endif
finished sourcing /usr/share/vim/vim81/syntax/nosyntax.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 16: endif
Executing: endif
line 17: 
Executing: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
Executing: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Executing: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/syntax/synload.vim"
Searching for "/var/lib/vim/addons/syntax/synload.vim"
Searching for "/etc/vim/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
Executing: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
Executing: " Last Change:^I2016 Nov 04
line 4: 
Executing: 
line 5: " This file sets up for syntax highlighting.
Executing: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
Executing: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
Executing: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
Executing: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
Executing: 
line 10: if !has("syntax")
Executing: if !has("syntax")
line 11:   finish
Executing:   finish
line 12: endif
Executing: endif
line 13: 
Executing: 
line 14: " let others know that syntax has been switched on
Executing: " let others know that syntax has been switched on
line 15: let syntax_on = 1
Executing: let syntax_on = 1
line 16: 
Executing: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
Executing: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
Executing: if exists("colors_name")
line 19:   exe "colors " . colors_name
Executing:   exe "colors " . colors_name
line 20: else
Executing: else
line 21:   runtime! syntax/syncolor.vim
Executing:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/etc/vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
Executing: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
Executing: " Last Change:^I2001 Sep 12
line 4: 
Executing: 
line 5: " This file sets up the default methods for highlighting.
Executing: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
Executing: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
Executing: " Also used from init_highlight().
line 8: 
Executing: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
Executing: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
Executing:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
Executing:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
Executing:   command -nargs=* SynLink hi link <args>
line 13: else
Executing: else
line 14:   if syntax_cmd == "enable"
Executing:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
Executing:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
Executing:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
Executing:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
Executing:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
Executing:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
Executing:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
Executing:     command -nargs=* SynLink hi! link <args>
line 22:   else
Executing:   else
line 23:     " User defined syncolor file has already set the colors.
Executing:     " User defined syncolor file has already set the colors.
line 24:     finish
Executing:     finish
line 25:   endif
Executing:   endif
line 26: endif
Executing: endif
line 27: 
Executing: 
line 28: " Many terminals can only use six different colors (plus black and white).
Executing: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
Executing: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
Executing: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
Executing: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
Executing: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
Executing: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
Executing:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
Executing:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
Executing:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
Executing:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
Executing:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
Executing:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
Executing:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
Executing:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
Executing:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
Executing: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
Executing:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
Executing: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
Executing:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
Executing: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
Executing:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
Executing: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
Executing:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
Executing: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
Executing:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
Executing: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
Executing:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
Executing: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
Executing:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
Executing: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
Executing:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
Executing: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
Executing:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
Executing: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
Executing: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
Executing: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
Executing: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
Executing: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
Executing: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
Executing: 
line 57: " Common groups that link to default highlighting.
Executing: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
Executing: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
Executing: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
Executing: hi link String^I^IConstant
line 60: SynLink Character^IConstant
Executing: SynLink Character^IConstant
line 60: hi link Character^IConstant
Executing: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
Executing: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
Executing: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
Executing: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
Executing: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
Executing: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
Executing: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
Executing: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
Executing: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
Executing: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
Executing: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
Executing: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
Executing: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
Executing: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
Executing: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
Executing: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
Executing: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
Executing: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
Executing: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
Executing: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
Executing: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
Executing: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
Executing: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
Executing: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
Executing: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
Executing: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
Executing: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
Executing: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
Executing: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
Executing: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
Executing: hi link StorageClass^IType
line 76: SynLink Structure^IType
Executing: SynLink Structure^IType
line 76: hi link Structure^IType
Executing: hi link Structure^IType
line 77: SynLink Typedef^I^IType
Executing: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
Executing: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
Executing: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
Executing: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
Executing: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
Executing: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
Executing: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
Executing: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
Executing: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
Executing: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
Executing: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
Executing: hi link Debug^I^ISpecial
line 83: 
Executing: 
line 84: delcommand SynColor
Executing: delcommand SynColor
line 85: delcommand SynLink
Executing: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/etc/vim/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/kangaroo/.vim/after/syntax/syncolor.vim"
line 22: endif
Executing: endif
line 23: 
Executing: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
Executing: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
Executing: let s:cpo_save = &cpo
line 26: set cpo&vim
Executing: set cpo&vim
line 27: 
Executing: 
line 28: " First remove all old syntax autocommands.
Executing: " First remove all old syntax autocommands.
line 29: au! Syntax
Executing: au! Syntax
line 30: 
Executing: 
line 31: au Syntax *^I^Icall s:SynSet()
Executing: au Syntax *^I^Icall s:SynSet()
line 32: 
Executing: 
line 33: fun! s:SynSet()
Executing: fun! s:SynSet()
line 61: 
Executing: 
line 62: 
Executing: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
Executing: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 64: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
Executing: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
Executing: 
line 70: 
Executing: 
line 71: " Source the user-specified syntax highlighting file
Executing: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
Executing: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
Executing:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
Executing:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
Executing:     execute "source " . fnameescape(s:fname)
line 76:   endif
Executing:   endif
line 77: endif
Executing: endif
line 78: 
Executing: 
line 79: " Restore 'cpoptions'
Executing: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
Executing: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
Executing: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
Executing: 
line 21: " Load the FileType autocommands if not done yet.
Executing: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
Executing: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
Executing:   let s:did_ft = 1
line 24: else
Executing: else
line 25:   filetype on
Executing:   filetype on
line 26:   let s:did_ft = 0
Executing:   let s:did_ft = 0
line 27: endif
Executing: endif
line 28: 
Executing: 
line 29: " Set up the connection between FileType and Syntax autocommands.
Executing: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
Executing: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
Executing: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
Executing:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
Executing: augroup END
line 34: 
Executing: 
line 35: 
Executing: 
line 36: " Execute the syntax autocommands for the each buffer.
Executing: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
Executing: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
Executing: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
Executing: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
Executing: doautoall syntaxset FileType
line 41: if !s:did_ft
Executing: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
Executing:   doautoall filetypedetect BufRead
line 43: endif
Executing: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in /usr/share/vim/vim81/defaults.vim
line 81: 
Executing: 
line 82:   " I like highlighting strings inside C comments.
Executing:   " I like highlighting strings inside C comments.
line 83:   " Revert with ":unlet c_comment_strings".
Executing:   " Revert with ":unlet c_comment_strings".
line 84:   let c_comment_strings=1
Executing:   let c_comment_strings=1
line 85: endif
Executing: endif
line 86: 
Executing: 
line 87: " Only do this part when Vim was compiled with the +eval feature.
Executing: " Only do this part when Vim was compiled with the +eval feature.
line 88: if 1
Executing: if 1
line 89: 
Executing: 
line 90:   " Enable file type detection.
Executing:   " Enable file type detection.
line 91:   " Use the default filetype settings, so that mail gets 'tw' set to 72,
Executing:   " Use the default filetype settings, so that mail gets 'tw' set to 72,
line 92:   " 'cindent' is on in C files, etc.
Executing:   " 'cindent' is on in C files, etc.
line 93:   " Also load indent files, to automatically do language-dependent indenting.
Executing:   " Also load indent files, to automatically do language-dependent indenting.
line 94:   " Revert with ":filetype off".
Executing:   " Revert with ":filetype off".
line 95:   filetype plugin indent on
Executing:   filetype plugin indent on
Searching for "filetype.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/etc/vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 95: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
Executing: " Vim support file to detect file types
line 2: "
Executing: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2019 Nov 01
Executing: " Last Change:^I2019 Nov 01
line 5: 
Executing: 
line 6: " Listen very carefully, I will say this only once
Executing: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
Executing: if exists("did_load_filetypes")
line 8:   finish
Executing:   finish
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in /usr/share/vim/vim81/defaults.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/etc/vim/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/kangaroo/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/ftplugin.vim"
Searching for "/var/lib/vim/addons/ftplugin.vim"
Searching for "/etc/vim/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim81/ftplugin.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 95: sourcing "/usr/share/vim/vim81/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
Executing: " Vim support file to switch on loading plugins for file types
line 2: "
Executing: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
Executing: " Last change:^I2006 Apr 30
line 5: 
Executing: 
line 6: if exists("did_load_ftplugin")
Executing: if exists("did_load_ftplugin")
line 7:   finish
Executing:   finish
line 8: endif
Executing: endif
line 9: let did_load_ftplugin = 1
Executing: let did_load_ftplugin = 1
line 10: 
Executing: 
line 11: augroup filetypeplugin
Executing: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
Executing:   au FileType * call s:LoadFTPlugin()
line 13: 
Executing: 
line 14:   func! s:LoadFTPlugin()
Executing:   func! s:LoadFTPlugin()
line 35: augroup END
Executing: augroup END
finished sourcing /usr/share/vim/vim81/ftplugin.vim
continuing in /usr/share/vim/vim81/defaults.vim
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/etc/vim/after/ftplugin.vim"
Searching for "/var/lib/vim/addons/after/ftplugin.vim"
Searching for "/home/kangaroo/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/indent.vim"
Searching for "/var/lib/vim/addons/indent.vim"
Searching for "/etc/vim/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim81/indent.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 95: sourcing "/usr/share/vim/vim81/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
Executing: " Vim support file to switch on loading indent files for file types
line 2: "
Executing: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
Executing: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
Executing: " Last Change:^I2008 Feb 22
line 5: 
Executing: 
line 6: if exists("did_indent_on")
Executing: if exists("did_indent_on")
line 7:   finish
Executing:   finish
line 8: endif
Executing: endif
line 9: let did_indent_on = 1
Executing: let did_indent_on = 1
line 10: 
Executing: 
line 11: augroup filetypeindent
Executing: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
Executing:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
Executing:   func! s:LoadIndent()
line 31: augroup END
Executing: augroup END
finished sourcing /usr/share/vim/vim81/indent.vim
continuing in /usr/share/vim/vim81/defaults.vim
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/etc/vim/after/indent.vim"
Searching for "/var/lib/vim/addons/after/indent.vim"
Searching for "/home/kangaroo/.vim/after/indent.vim"
line 96: 
Executing: 
line 97:   " Put these in an autocmd group, so that you can revert them with:
Executing:   " Put these in an autocmd group, so that you can revert them with:
line 98:   " ":augroup vimStartup | au! | augroup END"
Executing:   " ":augroup vimStartup | au! | augroup END"
line 99:   augroup vimStartup
Executing:   augroup vimStartup
line 100:     au!
Executing:     au!
line 101: 
Executing: 
line 102:     " When editing a file, always jump to the last known cursor position.
Executing:     " When editing a file, always jump to the last known cursor position.
line 103:     " Don't do it when the position is invalid, when inside an event handler
Executing:     " Don't do it when the position is invalid, when inside an event handler
line 104:     " (happens when dropping a file on gvim) and for a commit message (it's
Executing:     " (happens when dropping a file on gvim) and for a commit message (it's
line 105:     " likely a different one than last time).
Executing:     " likely a different one than last time).
line 106:     autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' |   exe "normal! g`\"" | endif
Executing:     autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' |   exe "normal! g`\"" | endif
line 110: 
Executing: 
line 111:   augroup END
Executing:   augroup END
line 112: 
Executing: 
line 113: endif
Executing: endif
line 114: 
Executing: 
line 115: " Convenient command to see the difference between the current buffer and the
Executing: " Convenient command to see the difference between the current buffer and the
line 116: " file it was loaded from, thus the changes you made.
Executing: " file it was loaded from, thus the changes you made.
line 117: " Only define it when not defined already.
Executing: " Only define it when not defined already.
line 118: " Revert with: ":delcommand DiffOrig".
Executing: " Revert with: ":delcommand DiffOrig".
line 119: if !exists(":DiffOrig")
Executing: if !exists(":DiffOrig")
line 120:   command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
Executing:   command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
line 122: endif
Executing: endif
line 123: 
Executing: 
line 124: if has('langmap') && exists('+langremap')
Executing: if has('langmap') && exists('+langremap')
line 125:   " Prevent that the langmap option applies to characters that result from a
Executing:   " Prevent that the langmap option applies to characters that result from a
line 126:   " mapping.  If set (default), this may break plugins (but it's backward
Executing:   " mapping.  If set (default), this may break plugins (but it's backward
line 127:   " compatible).
Executing:   " compatible).
line 128:   set nolangremap
Executing:   set nolangremap
line 129: endif
Executing: endif
finished sourcing $VIMRUNTIME/defaults.vim
could not source ".vimrc"
could not source ".exrc"
Searching for "pack/*/start/*" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/pack/*/start/*"
Searching for "/var/lib/vim/addons/pack/*/start/*"
Searching for "/etc/vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/etc/vim/after/pack/*/start/*"
Searching for "/var/lib/vim/addons/after/pack/*/start/*"
Searching for "/home/kangaroo/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/plugin/**/*.vim"
Searching for "/var/lib/vim/addons/plugin/**/*.vim"
Searching for "/etc/vim/plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
Searching for "/usr/share/vim/vim81/plugin/**/*.vim"
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
Executing: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
Executing: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
Executing: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
Executing: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
Executing: "  Usage:^I:help glvs
line 7: "
Executing: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
Executing: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
Executing: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
Executing: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
Executing: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
Executing: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
Executing: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
Executing: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
Executing: if exists("g:loaded_getscriptPlugin")
line 17:  finish
Executing:  finish
line 18: endif
Executing: endif
line 19: if &cp
Executing: if &cp
line 20:  if &verbose
Executing:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
Executing:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
Executing:  endif
line 23:  finish
Executing:  finish
line 24: endif
Executing: endif
line 25: let g:loaded_getscriptPlugin = "v36"
Executing: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
Executing: let s:keepcpo                = &cpo
line 27: set cpo&vim
Executing: set cpo&vim
line 28: 
Executing: 
line 29: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
Executing: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
Executing: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
Executing: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
Executing: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
Executing: 
line 35: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
Executing: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
Executing: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
Executing: unlet s:keepcpo
line 39: 
Executing: 
line 40: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
Executing: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/share/vim/vim81/plugin/getscriptPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
Executing: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
Executing: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Oct 30
Executing: " Last Change: 2016 Oct 30
line 4: 
Executing: 
line 5: " Exit quickly when:
Executing: " Exit quickly when:
line 6: " - this plugin was already loaded
Executing: " - this plugin was already loaded
line 7: " - when 'compatible' is set
Executing: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
Executing: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
Executing: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
Executing:   finish
line 11: endif
Executing: endif
line 12: let loaded_gzip = 1
Executing: let loaded_gzip = 1
line 13: 
Executing: 
line 14: augroup gzip
Executing: augroup gzip
line 15:   " Remove all gzip autocommands
Executing:   " Remove all gzip autocommands
line 16:   au!
Executing:   au!
line 17: 
Executing: 
line 18:   " Enable editing of gzipped files.
Executing:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
Executing:   " The functions are defined in autoload/gzip.vim.
line 20:   "
Executing:   "
line 21:   " Set binary mode before reading the file.
Executing:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
Executing:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
Executing:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
Executing:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
Executing:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
Executing:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
Executing:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
Executing:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
Executing:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
Executing:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
Executing:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
Executing:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
Executing:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
Executing:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
Executing:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
Executing:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
Executing:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
Executing:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
Executing:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
Executing:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
Executing:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
Executing:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
Executing:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
Executing:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
Executing:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
Executing:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
Executing:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
Executing:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
Executing:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
Executing:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
Executing:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 52: augroup END
Executing: augroup END
finished sourcing /usr/share/vim/vim81/plugin/gzip.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
Executing: " LogiPat: Boolean logical pattern matcher
line 2: "   Author:  Charles E. Campbell
Executing: "   Author:  Charles E. Campbell
line 3: "   Date:    Apr 04, 2016
Executing: "   Date:    Apr 04, 2016
line 4: "   Version: 4
Executing: "   Version: 4
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
Executing: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
Executing: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
Executing: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
Executing: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
Executing: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
Executing: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
Executing: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
Executing: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
Executing: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
Executing: "               of this software.
line 15: "
Executing: "
line 16: "   Usage: {{{1
Executing: "   Usage: {{{1
line 17: "       :LogiPat ...
Executing: "       :LogiPat ...
line 18: "
Executing: "
line 19: "         Boolean logic supported:
Executing: "         Boolean logic supported:
line 20: "            () grouping operators
Executing: "            () grouping operators
line 21: "            !  not the following pattern
Executing: "            !  not the following pattern
line 22: "            |  logical or
Executing: "            |  logical or
line 23: "            &  logical and
Executing: "            &  logical and
line 24: "            "..pattern.."
Executing: "            "..pattern.."
line 25: "^IExample: {{{1
Executing: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
Executing: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
Executing: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
Executing: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
Executing: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
Executing: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
Executing: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
Executing: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
Executing: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
Executing: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
Executing: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
Executing: 
line 37: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
Executing: " Load Once: {{{1
line 39: if &cp || exists("loaded_logiPat")
Executing: if &cp || exists("loaded_logiPat")
line 40:  finish
Executing:  finish
line 41: endif
Executing: endif
line 42: let g:loaded_logiPat = "v4"
Executing: let g:loaded_logiPat = "v4"
line 43: let s:keepcpo        = &cpo
Executing: let s:keepcpo        = &cpo
line 44: set cpo&vim
Executing: set cpo&vim
line 45: "DechoRemOn
Executing: "DechoRemOn
line 46: 
Executing: 
line 47: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
Executing: " Public Interface: {{{1
line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
Executing: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
Executing: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
Executing: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
Executing: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
Executing: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
Executing: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 55: 
Executing: 
line 56: " =====================================================================
Executing: " =====================================================================
line 57: " Functions: {{{1
Executing: " Functions: {{{1
line 58: 
Executing: 
line 59: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2
Executing: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 61: fun! LogiPat(pat,...)
Executing: fun! LogiPat(pat,...)
line 146: 
Executing: 
line 147: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 148: " s:String: Vim6.4 doesn't have string() {{{2
Executing: " s:String: Vim6.4 doesn't have string() {{{2
line 149: func! s:String(str)
Executing: func! s:String(str)
line 152: 
Executing: 
line 153: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 154: " LP_PatPush: {{{2
Executing: " LP_PatPush: {{{2
line 155: fun! s:LP_PatPush(pat)
Executing: fun! s:LP_PatPush(pat)
line 162: 
Executing: 
line 163: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
Executing: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 165: fun! s:LP_PatPop(lookup)
Executing: fun! s:LP_PatPop(lookup)
line 178: 
Executing: 
line 179: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 180: " LP_OpPush: {{{2
Executing: " LP_OpPush: {{{2
line 181: fun! s:LP_OpPush(op)
Executing: fun! s:LP_OpPush(op)
line 232: 
Executing: 
line 233: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2
Executing: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 235: fun! s:LP_Execute(preclvl)
Executing: fun! s:LP_Execute(preclvl)
line 265: 
Executing: 
line 266: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 267: " LP_Not: writes a logical-not for a pattern {{{2
Executing: " LP_Not: writes a logical-not for a pattern {{{2
line 268: fun! s:LP_Not(pat)
Executing: fun! s:LP_Not(pat)
line 279: 
Executing: 
line 280: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 281: " LP_Or: writes a logical-or branch using two patterns {{{2
Executing: " LP_Or: writes a logical-or branch using two patterns {{{2
line 282: fun! s:LP_Or(pat1,pat2)
Executing: fun! s:LP_Or(pat1,pat2)
line 288: 
Executing: 
line 289: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 290: " LP_And: writes a logical-and concat using two patterns {{{2
Executing: " LP_And: writes a logical-and concat using two patterns {{{2
line 291: fun! s:LP_And(pat1,pat2)
Executing: fun! s:LP_And(pat1,pat2)
line 297: 
Executing: 
line 298: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 299: " StackLook: {{{2
Executing: " StackLook: {{{2
line 300: fun! s:StackLook(description)
Executing: fun! s:StackLook(description)
line 334: 
Executing: 
line 335: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 336: "  Cleanup And Modeline: {{{1
Executing: "  Cleanup And Modeline: {{{1
line 337: let &cpo= s:keepcpo
Executing: let &cpo= s:keepcpo
line 338: unlet s:keepcpo
Executing: unlet s:keepcpo
line 339: " vim: ts=4 fdm=marker
Executing: " vim: ts=4 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/logiPat.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
Executing: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
Executing: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2018 Feb 04
Executing: " Last Change: 2018 Feb 04
line 4: 
Executing: 
line 5: command! -nargs=0 MANPAGER call s:ManPager() | delcommand MANPAGER
Executing: command! -nargs=0 MANPAGER call s:ManPager() | delcommand MANPAGER
line 6: 
Executing: 
line 7: function! s:ManPager()
Executing: function! s:ManPager()
finished sourcing /usr/share/vim/vim81/plugin/manpager.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
Executing: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
Executing: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2019 Oct 28
Executing: " Last Change: 2019 Oct 28
line 4: 
Executing: 
line 5: " Exit quickly when:
Executing: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
Executing: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
Executing: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
Executing: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
Executing: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
Executing:   finish
line 11: endif
Executing: endif
line 12: let g:loaded_matchparen = 1
Executing: let g:loaded_matchparen = 1
line 13: 
Executing: 
line 14: if !exists("g:matchparen_timeout")
Executing: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
Executing:   let g:matchparen_timeout = 300
line 16: endif
Executing: endif
line 17: if !exists("g:matchparen_insert_timeout")
Executing: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
Executing:   let g:matchparen_insert_timeout = 60
line 19: endif
Executing: endif
line 20: 
Executing: 
line 21: augroup matchparen
Executing: augroup matchparen
line 22:   " Replace all matchparen autocommands
Executing:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
Executing:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
Executing:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
Executing:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
Executing:   endif
line 27: augroup END
Executing: augroup END
line 28: 
Executing: 
line 29: " Skip the rest if it was already done.
Executing: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
Executing: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
Executing:   finish
line 32: endif
Executing: endif
line 33: 
Executing: 
line 34: let s:cpo_save = &cpo
Executing: let s:cpo_save = &cpo
line 35: set cpo-=C
Executing: set cpo-=C
line 36: 
Executing: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
Executing: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
Executing: " for any matching paren.
line 39: func s:Highlight_Matching_Pair()
Executing: func s:Highlight_Matching_Pair()
line 197: 
Executing: 
line 198: " Define commands that will disable and enable the plugin.
Executing: " Define commands that will disable and enable the plugin.
line 199: command DoMatchParen call s:DoMatchParen()
Executing: command DoMatchParen call s:DoMatchParen()
line 200: command NoMatchParen call s:NoMatchParen()
Executing: command NoMatchParen call s:NoMatchParen()
line 201: 
Executing: 
line 202: func s:NoMatchParen()
Executing: func s:NoMatchParen()
line 209: 
Executing: 
line 210: func s:DoMatchParen()
Executing: func s:DoMatchParen()
line 216: 
Executing: 
line 217: let &cpo = s:cpo_save
Executing: let &cpo = s:cpo_save
line 218: unlet s:cpo_save
Executing: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/plugin/matchparen.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
Executing: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
Executing: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 08, 2016 (update for gx 2019 Sep 20)
Executing: " Date:^I^IFeb 08, 2016 (update for gx 2019 Sep 20)
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
Executing: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
Executing: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
Executing: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
Executing: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
Executing: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
Executing: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
Executing: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
Executing: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
Executing: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
Executing: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
Executing: "               resulting from the use of this software.
line 15: "
Executing: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
Executing: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
Executing: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Executing: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
Executing: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
Executing: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
Executing:  finish
line 22: endif
Executing: endif
line 23: let g:loaded_netrwPlugin = "v165"
Executing: let g:loaded_netrwPlugin = "v165"
line 24: let s:keepcpo = &cpo
Executing: let s:keepcpo = &cpo
line 25: set cpo&vim
Executing: set cpo&vim
line 26: "DechoRemOn
Executing: "DechoRemOn
line 27: 
Executing: 
line 28: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
Executing: " Public Interface: {{{1
line 30: 
Executing: 
line 31: " Local Browsing Autocmds: {{{2
Executing: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
Executing: augroup FileExplorer
line 33:  au!
Executing:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
Executing:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
Executing:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
Executing:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
Executing:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
Executing:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
Executing:  endif
line 40: augroup END
Executing: augroup END
line 41: 
Executing: 
line 42: " Network Browsing Reading Writing: {{{2
Executing: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
Executing: augroup Network
line 44:  au!
Executing:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))
Executing:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
Executing:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
Executing:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
Executing:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
Executing:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try
Executing:  try
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
Executing:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/
Executing:  catch /^Vim\%((\a\+)\)\=:E216/
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
Executing:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
Executing:  endtry
line 55: augroup END
Executing: augroup END
line 56: 
Executing: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
Executing: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
Executing: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
Executing: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
Executing: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
Executing: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)
Executing: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)
line 63: 
Executing: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
Executing: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
Executing: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
Executing: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
Executing: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
Executing: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
Executing: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
Executing: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
Executing: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
Executing: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
Executing: 
line 74: " Commands: NetrwSettings {{{2
Executing: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
Executing: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
Executing: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
Executing: 
line 78: " Maps:
Executing: " Maps:
line 79: if !exists("g:netrw_nogx")
Executing: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
Executing:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
Executing:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
Executing:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
Executing:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
Executing:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
line 85:  endif
Executing:  endif
line 86:  if maparg('gx','v') == ""
Executing:  if maparg('gx','v') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
Executing:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis
Executing:    vmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
Executing:   endif
line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
Executing:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
Executing:  endif
line 92: endif
Executing: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
Executing: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
Executing:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
Executing:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
Executing:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
Executing:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
Executing: endif
line 99: 
Executing: 
line 100: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
Executing: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
Executing: fun! s:LocalBrowse(dirname)
line 144: 
Executing: 
line 145: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 146: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
Executing: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 147: "             Its purpose: to look over all windows and run s:LocalBrowse() on
Executing: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 148: "             them, which checks if they're directories and will create a directory
Executing: "             them, which checks if they're directories and will create a directory
line 149: "             listing when appropriate.
Executing: "             listing when appropriate.
line 150: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
Executing: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 151: "             has already been called.
Executing: "             has already been called.
line 152: fun! s:VimEnter(dirname)
Executing: fun! s:VimEnter(dirname)
line 160: 
Executing: 
line 161: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 162: " NetrwStatusLine: {{{1
Executing: " NetrwStatusLine: {{{1
line 163: fun! NetrwStatusLine()
Executing: fun! NetrwStatusLine()
line 174: 
Executing: 
line 175: " ------------------------------------------------------------------------
Executing: " ------------------------------------------------------------------------
line 176: " NetUserPass: set username and password for subsequent ftp transfer {{{1
Executing: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 177: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
Executing: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 178: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
Executing: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 179: "^I    :call NetUserPass("uid","password") -- sets global userid and password
Executing: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 180: fun! NetUserPass(...)
Executing: fun! NetUserPass(...)
line 204: 
Executing: 
line 205: " ------------------------------------------------------------------------
Executing: " ------------------------------------------------------------------------
line 206: " Modelines And Restoration: {{{1
Executing: " Modelines And Restoration: {{{1
line 207: let &cpo= s:keepcpo
Executing: let &cpo= s:keepcpo
line 208: unlet s:keepcpo
Executing: unlet s:keepcpo
line 209: " vim:ts=8 fdm=marker
Executing: " vim:ts=8 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/netrwPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
Executing: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
Executing: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
Executing: " Last Change: 2008 May 29
line 4: 
Executing: 
line 5: " Has this already been loaded?
Executing: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
Executing: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
Executing:   finish
finished sourcing /usr/share/vim/vim81/plugin/rrhelper.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
Executing: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
Executing: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
Executing: " Last Change: 2006 Feb 01
line 4: 
Executing: 
line 5: " Exit quickly when:
Executing: " Exit quickly when:
line 6: " - this plugin was already loaded
Executing: " - this plugin was already loaded
line 7: " - when 'compatible' is set
Executing: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
Executing: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
Executing: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
Executing:   finish
line 11: endif
Executing: endif
line 12: let loaded_spellfile_plugin = 1
Executing: let loaded_spellfile_plugin = 1
line 13: 
Executing: 
line 14: " The function is in the autoload directory.
Executing: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
Executing: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/vim/vim81/plugin/spellfile.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
Executing: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
Executing: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
Executing: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
Executing: " Distributed under the GNU General Public License.
line 5: "
Executing: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
Executing: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
Executing: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
Executing: " let me know.
line 9: " Also look there for further comments and documentation.
Executing: " Also look there for further comments and documentation.
line 10: "
Executing: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
Executing: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
Executing: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
Executing: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
Executing:  finish
line 16: endif
Executing: endif
line 17: let g:loaded_tarPlugin = "v29"
Executing: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
Executing: let s:keepcpo          = &cpo
line 19: set cpo&vim
Executing: set cpo&vim
line 20: 
Executing: 
line 21: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
Executing: "  Public Interface: {{{1
line 23: augroup tar
Executing: augroup tar
line 24:   au!
Executing:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
Executing:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
Executing:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
Executing:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
Executing:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
Executing: 
line 30:   if has("unix")
Executing:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
Executing:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
Executing:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
Executing:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
Executing:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
Executing:   endif
line 36: 
Executing: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
Executing:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47: augroup END
Executing: augroup END
line 48: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
Executing: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 49: 
Executing: 
line 50: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 51: " Restoration And Modelines: {{{1
Executing: " Restoration And Modelines: {{{1
line 52: " vim: fdm=marker
Executing: " vim: fdm=marker
line 53: let &cpo= s:keepcpo
Executing: let &cpo= s:keepcpo
line 54: unlet s:keepcpo
Executing: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/tarPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
Executing: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
Executing: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2018 Nov 11
Executing: " Last Change: 2018 Nov 11
line 4: "
Executing: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
Executing: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
Executing: " $VIMRUNTIME/syntax/2html.vim
line 7: "
Executing: "
line 8: if exists('g:loaded_2html_plugin')
Executing: if exists('g:loaded_2html_plugin')
line 9:   finish
Executing:   finish
line 10: endif
Executing: endif
line 11: let g:loaded_2html_plugin = 'vim8.1_v1'
Executing: let g:loaded_2html_plugin = 'vim8.1_v1'
line 12: 
Executing: 
line 13: "
Executing: "
line 14: " Changelog: {{{
Executing: " Changelog: {{{
line 15: "   8.1_v1  (this version): Fix Bitbucket issue #6: Don't generate empty script
Executing: "   8.1_v1  (this version): Fix Bitbucket issue #6: Don't generate empty script
line 16: "                           tag.
Executing: "                           tag.
line 17: "                           Fix Bitbucket issue #5: javascript should
Executing: "                           Fix Bitbucket issue #5: javascript should
line 18: "                           declare variables with "var".
Executing: "                           declare variables with "var".
line 19: "                           Fix Bitbucket issue #13: errors thrown sourcing
Executing: "                           Fix Bitbucket issue #13: errors thrown sourcing
line 20: "                           2html.vim directly when plugins not loaded.
Executing: "                           2html.vim directly when plugins not loaded.
line 21: "                           Fix Bitbucket issue #16: support 'vartabstop'.
Executing: "                           Fix Bitbucket issue #16: support 'vartabstop'.
line 22: "
Executing: "
line 23: "   7.4 updates: {{{
Executing: "   7.4 updates: {{{
line 24: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
Executing: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 25: "                           an empty buffer. Jan Stocker: allow g:html_font to
Executing: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 26: "                           take a list so it is easier to specfiy fallback
Executing: "                           take a list so it is easier to specfiy fallback
line 27: "                           fonts in the generated CSS.
Executing: "                           fonts in the generated CSS.
line 28: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
Executing: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 29: "^I^I^I    also for version-specific modelines like "vim>703:".
Executing: "^I^I^I    also for version-specific modelines like "vim>703:".
line 30: "}}}
Executing: "}}}
line 31: "
Executing: "
line 32: "   7.3 updates: {{{
Executing: "   7.3 updates: {{{
line 33: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
Executing: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 34: "^I^I^I    g:html_line_ids=0. Allow customizing
Executing: "^I^I^I    g:html_line_ids=0. Allow customizing
line 35: "^I^I^I    important IDs (like line IDs and fold IDs) using
Executing: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 36: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
Executing: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 37: "^I^I^I    is started.
Executing: "^I^I^I    is started.
line 38: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
Executing: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 39: "^I^I^I    insert modeline to set it to manual.
Executing: "^I^I^I    insert modeline to set it to manual.
line 40: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
Executing: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 41: "^I^I^I    duplicate of one buffer instead of including both.
Executing: "^I^I^I    duplicate of one buffer instead of including both.
line 42: "^I^I^I    Add anchors to each line so you can put '#L123'
Executing: "^I^I^I    Add anchors to each line so you can put '#L123'
line 43: "^I^I^I    or '#123' at the end of the URL to jump to line 123
Executing: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 44: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
Executing: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 45: "^I^I^I    to show the anchor being jumped to if it is hidden.
Executing: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 46: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
Executing: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 47: "^I^I^I    Allow TOhtml to chain together with other commands
Executing: "^I^I^I    Allow TOhtml to chain together with other commands
line 48: "^I^I^I    using |.
Executing: "^I^I^I    using |.
line 49: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
Executing: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 50: "^I^I^I    highlight groups make up the start-of-modeline text.
Executing: "^I^I^I    highlight groups make up the start-of-modeline text.
line 51: "^I^I^I    Improve render time of page with uncopyable regions
Executing: "^I^I^I    Improve render time of page with uncopyable regions
line 52: "^I^I^I    by not using one-input-per-char. Change name of
Executing: "^I^I^I    by not using one-input-per-char. Change name of
line 53: "^I^I^I    uncopyable option from html_unselectable to
Executing: "^I^I^I    uncopyable option from html_unselectable to
line 54: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
Executing: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 55: "^I^I^I    default to inserting invalid markup for uncopyable
Executing: "^I^I^I    default to inserting invalid markup for uncopyable
line 56: "^I^I^I    regions to prevent MS Word from pasting undeletable
Executing: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 57: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
Executing: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 58: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
Executing: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 59: "^I^I^I    eliminate post-processing substitute commands in
Executing: "^I^I^I    eliminate post-processing substitute commands in
line 60: "^I^I^I    favor of doing the work up front. Remove unnecessary
Executing: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 61: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
Executing: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 62: "^I^I^I    speed improvements. Fix modeline mangling in
Executing: "^I^I^I    speed improvements. Fix modeline mangling in
line 63: "^I^I^I    generated output so it works for text in the first
Executing: "^I^I^I    generated output so it works for text in the first
line 64: "^I^I^I    column. Fix missing line number and fold column in
Executing: "^I^I^I    column. Fix missing line number and fold column in
line 65: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
Executing: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 66: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
Executing: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 67: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
Executing: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 68: "^I^I^I    the new default foldtext added in v11, as the patch
Executing: "^I^I^I    the new default foldtext added in v11, as the patch
line 69: "^I^I^I    adding it has not yet been included in Vim.
Executing: "^I^I^I    adding it has not yet been included in Vim.
line 70: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
Executing: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 71: "^I^I^I    Brabandt in
Executing: "^I^I^I    Brabandt in
line 72: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
Executing: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 73: "^I^I^I    This patch has not yet been included in Vim, thus
Executing: "^I^I^I    This patch has not yet been included in Vim, thus
line 74: "^I^I^I    these changes are removed in the next version.
Executing: "^I^I^I    these changes are removed in the next version.
line 75: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
Executing: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 76: "^I^I^I    multiple nested folds with dynamic folding on.
Executing: "^I^I^I    multiple nested folds with dynamic folding on.
line 77: "^I^I^I    Also fix problem with foldtext in this situation.
Executing: "^I^I^I    Also fix problem with foldtext in this situation.
line 78: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
Executing: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 79: "^I^I^I    and without html_no_pre, default value same as
Executing: "^I^I^I    and without html_no_pre, default value same as
line 80: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
Executing: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 81: "^I^I^I    'fileencoding' for converted document encoding if
Executing: "^I^I^I    'fileencoding' for converted document encoding if
line 82: "^I^I^I    'buftype' indicates a special buffer which isn't
Executing: "^I^I^I    'buftype' indicates a special buffer which isn't
line 83: "^I^I^I    written.
Executing: "^I^I^I    written.
line 84: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
Executing: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 85: "^I^I^I    characters in generated output (Andy Spencer).
Executing: "^I^I^I    characters in generated output (Andy Spencer).
line 86: "^I^I^I    Escape text that looks like a modeline so Vim
Executing: "^I^I^I    Escape text that looks like a modeline so Vim
line 87: "^I^I^I    doesn't use anything in the converted HTML as a
Executing: "^I^I^I    doesn't use anything in the converted HTML as a
line 88: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
Executing: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 89: "^I^I^I    before the conversion range. Remove fold column when
Executing: "^I^I^I    before the conversion range. Remove fold column when
line 90: "^I^I^I    there are no folds.
Executing: "^I^I^I    there are no folds.
line 91: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
Executing: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 92: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
Executing: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 93: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
Executing: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 94: "^I^I^I    supported by all major browsers according to
Executing: "^I^I^I    supported by all major browsers according to
line 95: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
Executing: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 96: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
Executing: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 97: "^I^I^I    HTML encoding to Vim encoding detection be
Executing: "^I^I^I    HTML encoding to Vim encoding detection be
line 98: "^I^I^I    case-insensitive for built-in pairs.
Executing: "^I^I^I    case-insensitive for built-in pairs.
line 99: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
Executing: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 100: "^I^I^I    called in restricted mode (Andy Spencer). Use
Executing: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 101: "^I^I^I    'fencoding' instead of 'encoding' to determine by
Executing: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 102: "^I^I^I    charset, and make sure the 'fenc' of the generated
Executing: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 103: "^I^I^I    file matches its indicated charset. Add charsets for
Executing: "^I^I^I    file matches its indicated charset. Add charsets for
line 104: "^I^I^I    all of Vim's natively supported encodings.
Executing: "^I^I^I    all of Vim's natively supported encodings.
line 105: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
Executing: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 106: "^I^I^I    user settings interfering with diff mode generation,
Executing: "^I^I^I    user settings interfering with diff mode generation,
line 107: "^I^I^I    trailing whitespace (e.g. line number column) when
Executing: "^I^I^I    trailing whitespace (e.g. line number column) when
line 108: "^I^I^I    using html_no_pre, and bugs when using
Executing: "^I^I^I    using html_no_pre, and bugs when using
line 109: "^I^I^I    html_hover_unfold.
Executing: "^I^I^I    html_hover_unfold.
line 110: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
Executing: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 111: "^I^I^I    folds in diff mode when first line was folded.
Executing: "^I^I^I    folds in diff mode when first line was folded.
line 112: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
Executing: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 113: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
Executing: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 114: "^I^I^I    default to true when not set to anything. Use strict
Executing: "^I^I^I    default to true when not set to anything. Use strict
line 115: "^I^I^I    doctypes where possible. Rename use_xhtml option to
Executing: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 116: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
Executing: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 117: "^I^I^I    when using this option. Add meta tag for settings.
Executing: "^I^I^I    when using this option. Add meta tag for settings.
line 118: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
Executing: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 119: "^I^I^I    diff colors and the normal syntax colors
Executing: "^I^I^I    diff colors and the normal syntax colors
line 120: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
Executing: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 121: "}}}
Executing: "}}}
line 122: "}}}
Executing: "}}}
line 123: 
Executing: 
line 124: " TODO: {{{
Executing: " TODO: {{{
line 125: "   * Check the issue tracker:
Executing: "   * Check the issue tracker:
line 126: "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
Executing: "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
line 127: "   * Options for generating the CSS in external style sheets. New :TOcss
Executing: "   * Options for generating the CSS in external style sheets. New :TOcss
line 128: "     command to convert the current color scheme into a (mostly) generic CSS
Executing: "     command to convert the current color scheme into a (mostly) generic CSS
line 129: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
Executing: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 130: "     by Erik Falor
Executing: "     by Erik Falor
line 131: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
Executing: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 132: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
Executing: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 133: "     term) to use for the styling. Suggestion by "nacitar".
Executing: "     term) to use for the styling. Suggestion by "nacitar".
line 134: "   * Add way to override or specify which RGB colors map to the color numbers
Executing: "   * Add way to override or specify which RGB colors map to the color numbers
line 135: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
Executing: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 136: "   * Disable filetype detection until after all processing is done.
Executing: "   * Disable filetype detection until after all processing is done.
line 137: "   * Add option for not generating the hyperlink on stuff that looks like a
Executing: "   * Add option for not generating the hyperlink on stuff that looks like a
line 138: "     URL? Or just color the link to fit with the colorscheme (and only special
Executing: "     URL? Or just color the link to fit with the colorscheme (and only special
line 139: "     when hovering)?
Executing: "     when hovering)?
line 140: "   * Bug: Opera does not allow printing more than one page if uncopyable
Executing: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 141: "     regions is turned on. Possible solution: Add normal text line numbers with
Executing: "     regions is turned on. Possible solution: Add normal text line numbers with
line 142: "     display:none, set to display:inline for print style sheets, and hide
Executing: "     display:none, set to display:inline for print style sheets, and hide
line 143: "     <input> elements for print, to allow Opera printing multiple pages (and
Executing: "     <input> elements for print, to allow Opera printing multiple pages (and
line 144: "     other uncopyable areas?). May need to make the new text invisible to IE
Executing: "     other uncopyable areas?). May need to make the new text invisible to IE
line 145: "     with conditional comments to prevent copying it, IE for some reason likes
Executing: "     with conditional comments to prevent copying it, IE for some reason likes
line 146: "     to copy hidden text. Other browsers too?
Executing: "     to copy hidden text. Other browsers too?
line 147: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
Executing: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 148: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
Executing: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 149: "     on Windows). Perhaps it is font related?
Executing: "     on Windows). Perhaps it is font related?
line 150: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
Executing: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 151: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
Executing: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 152: "     on diff lines though.
Executing: "     on diff lines though.
line 153: "   * Undercurl support via CSS3, with fallback to dotted or something:
Executing: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 154: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
Executing: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 155: "   * Redo updates for modified default foldtext (v11) when/if the patch is
Executing: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 156: "     accepted to modify it.
Executing: "     accepted to modify it.
line 157: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
Executing: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 158: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
Executing: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 159: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
Executing: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 160: "     does not show the whole diff filler as it is supposed to?
Executing: "     does not show the whole diff filler as it is supposed to?
line 161: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
Executing: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 162: "     invalid content. Can/should anything be done about this? Maybe a separate
Executing: "     invalid content. Can/should anything be done about this? Maybe a separate
line 163: "     plugin to correct 'isprint' based on encoding?
Executing: "     plugin to correct 'isprint' based on encoding?
line 164: "   * Check to see if the windows-125\d encodings actually work in Unix without
Executing: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 165: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
Executing: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 166: "   * Font auto-detection similar to
Executing: "   * Font auto-detection similar to
line 167: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
Executing: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 168: "     platforms.
Executing: "     platforms.
line 169: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
Executing: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 170: "^I- listchars support
Executing: "^I- listchars support
line 171: "^I- full-line background highlight
Executing: "^I- full-line background highlight
line 172: "^I- other?
Executing: "^I- other?
line 173: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
Executing: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 174: "     free with full-line background highlight above).
Executing: "     free with full-line background highlight above).
line 175: "   * Restore open/closed folds and cursor position after processing each file
Executing: "   * Restore open/closed folds and cursor position after processing each file
line 176: "     with option not to restore for speed increase.
Executing: "     with option not to restore for speed increase.
line 177: "   * Add extra meta info (generation time, etc.)?
Executing: "   * Add extra meta info (generation time, etc.)?
line 178: "   * Tidy up so we can use strict doctype in even more situations
Executing: "   * Tidy up so we can use strict doctype in even more situations
line 179: "   * Implementation detail: add threshold for writing the lines to the html
Executing: "   * Implementation detail: add threshold for writing the lines to the html
line 180: "     buffer before we're done (5000 or so lines should do it)
Executing: "     buffer before we're done (5000 or so lines should do it)
line 181: "   * TODO comments for code cleanup scattered throughout
Executing: "   * TODO comments for code cleanup scattered throughout
line 182: "}}}
Executing: "}}}
line 183: 
Executing: 
line 184: " Define the :TOhtml command when:
Executing: " Define the :TOhtml command when:
line 185: " - 'compatible' is not set
Executing: " - 'compatible' is not set
line 186: " - this plugin or user override was not already loaded
Executing: " - this plugin or user override was not already loaded
line 187: " - user commands are available. {{{
Executing: " - user commands are available. {{{
line 188: if !&cp && !exists(":TOhtml") && has("user_commands")
Executing: if !&cp && !exists(":TOhtml") && has("user_commands")
line 189:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
Executing:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 190: endif "}}}
Executing: endif "}}}
line 191: 
Executing: 
line 192: " Make sure any patches will probably use consistent indent
Executing: " Make sure any patches will probably use consistent indent
line 193: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
Executing: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/tohtml.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
Executing: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell
Executing: " Author: Charles E. Campbell
line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell
Executing: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
Executing: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
Executing: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
Executing: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
Executing: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
Executing: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
Executing: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
Executing: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
Executing: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
Executing: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
Executing: 
line 14: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
Executing: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
Executing: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
Executing:  finish
line 18: endif
Executing: endif
line 19: let g:loaded_vimballPlugin = "v37"
Executing: let g:loaded_vimballPlugin = "v37"
line 20: let s:keepcpo              = &cpo
Executing: let s:keepcpo              = &cpo
line 21: set cpo&vim
Executing: set cpo&vim
line 22: 
Executing: 
line 23: " ------------------------------------------------------------------------------
Executing: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
Executing: " Public Interface: {{{1
line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
Executing: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
Executing: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
Executing: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
Executing: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: augroup Vimball
Executing: augroup Vimball
line 30:  au!
Executing:  au!
line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
Executing:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
Executing:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
Executing:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
Executing:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
Executing:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
Executing:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 37: augroup END
Executing: augroup END
line 38: 
Executing: 
line 39: " =====================================================================
Executing: " =====================================================================
line 40: " Restoration And Modelines: {{{1
Executing: " Restoration And Modelines: {{{1
line 41: " vim: fdm=marker
Executing: " vim: fdm=marker
line 42: let &cpo= s:keepcpo
Executing: let &cpo= s:keepcpo
line 43: unlet s:keepcpo
Executing: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/vimballPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
Executing: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
Executing: "            PLUGIN PORTION
line 3: " Date:^I^I^ISep 13, 2016
Executing: " Date:^I^I^ISep 13, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
Executing: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
Executing: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
Executing: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
Executing: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
Executing: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
Executing: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
Executing: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
Executing: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
Executing: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
Executing: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
Executing: "               of this software.
line 15: "
Executing: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
Executing: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
Executing: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
Executing: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
Executing: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
Executing:  finish
line 22: endif
Executing: endif
line 23: let g:loaded_zipPlugin = "v28"
Executing: let g:loaded_zipPlugin = "v28"
line 24: let s:keepcpo          = &cpo
Executing: let s:keepcpo          = &cpo
line 25: set cpo&vim
Executing: set cpo&vim
line 26: 
Executing: 
line 27: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 28: " Options: {{{1
Executing: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
Executing: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
Executing:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
Executing: endif
line 32: 
Executing: 
line 33: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
Executing: " Public Interface: {{{1
line 35: augroup zip
Executing: augroup zip
line 36:  au!
Executing:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
Executing:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
Executing:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
Executing:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
Executing:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
Executing: 
line 42:  if has("unix")
Executing:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
Executing:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
Executing:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
Executing:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
Executing:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
Executing:  endif
line 48: 
Executing: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
Executing:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
Executing: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
Executing: augroup END
line 51: 
Executing: 
line 52: " ---------------------------------------------------------------------
Executing: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
Executing: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
Executing: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
Executing: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
Executing: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/zipPlugin.vim
Searching for "pack/*/start/*" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/home/kangaroo/.vim/pack/*/start/*"
Searching for "/var/lib/vim/addons/pack/*/start/*"
Searching for "/etc/vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/etc/vim/after/pack/*/start/*"
Searching for "/var/lib/vim/addons/after/pack/*/start/*"
Searching for "/home/kangaroo/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/kangaroo/.vim,/var/lib/vim/addons,/etc/vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/etc/vim/after,/var/lib/vim/addons/after,/home/kangaroo/.vim/after"
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/etc/vim/after/plugin/**/*.vim"
Searching for "/var/lib/vim/addons/after/plugin/**/*.vim"
Searching for "/home/kangaroo/.vim/after/plugin/**/*.vim"
not found in 'runtimepath': "plugin/**/*.vim"
Reading viminfo file "/home/kangaroo/.viminfo" info oldfiles
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling function <SNR>16_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
Executing:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
Executing:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
Executing:   " the DBG buffer are made.
line 4: 
Executing: 
line 5:   if !exists("s:vimentered")
Executing:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
Executing:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
Executing:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
Executing: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
Executing: "   call Dret("s:LocalBrowse")
line 10:    return
Executing:    return
function <SNR>16_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand sil call s:VimEnter(expand("<amatch>"))

Executing: sil call s:VimEnter(expand("<amatch>"))
Executing: sil call s:VimEnter(expand("<amatch>"))
calling function <SNR>16_VimEnter('')

line 1: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
Executing: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
line 2:   let curwin       = winnr()
Executing:   let curwin       = winnr()
line 3:   let s:vimentered = 1
Executing:   let s:vimentered = 1
line 4:   windo call s:LocalBrowse(expand("%:p"))
Executing:   windo call s:LocalBrowse(expand("%:p"))
line 4: call s:LocalBrowse(expand("%:p"))
Executing: call s:LocalBrowse(expand("%:p"))
calling function <SNR>16_VimEnter[4]..<SNR>16_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
Executing:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
Executing:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
Executing:   " the DBG buffer are made.
line 4: 
Executing: 
line 5:   if !exists("s:vimentered")
Executing:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
Executing:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
Executing:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
Executing: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
Executing: "   call Dret("s:LocalBrowse")
line 10:    return
Executing:    return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
Executing: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
Executing: 
line 15:   if has("amiga")
Executing:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
Executing:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
Executing:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
Executing:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
Executing: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
Executing:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
Executing:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
Executing:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 23:      exe w:netrw_bannercnt
Executing:      exe w:netrw_bannercnt
line 24:     endif
Executing:     endif
line 25:    endif
Executing:    endif
line 26: 
Executing: 
line 27:   elseif isdirectory(a:dirname)
Executing:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
Executing: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
Executing: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    sil! call netrw#LocalBrowseCheck(a:dirname)
Executing:    sil! call netrw#LocalBrowseCheck(a:dirname)
line 31:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
Executing:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 32:     exe w:netrw_bannercnt
Executing:     exe w:netrw_bannercnt
line 33:    endif
Executing:    endif
line 34: 
Executing: 
line 35:   else
Executing:   else
line 36:    " not a directory, ignore it
Executing:    " not a directory, ignore it
line 37: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
Executing: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 38:   endif
Executing:   endif
line 39: 
Executing: 
line 40: "  call Dret("s:LocalBrowse")
Executing: "  call Dret("s:LocalBrowse")
function <SNR>16_VimEnter[4]..<SNR>16_LocalBrowse returning #0

continuing in function <SNR>16_VimEnter

line 5:   exe curwin."wincmd w"
Executing:   exe curwin."wincmd w"
line 5: 1wincmd w
Executing: 1wincmd w
line 6: "  call Dret("s:VimEnter")
Executing: "  call Dret("s:VimEnter")
function <SNR>16_VimEnter returning #0

continuing in VimEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"
-- INSERT --
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling function <SNR>15_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
Executing:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
Executing:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
Executing:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
Executing:     let w:paren_hl_on = 0
line 5:   endif
Executing:   endif
line 6: 
Executing: 
line 7:   " Avoid that we remove the popup menu.
Executing:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
Executing:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
Executing:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
Executing:     return
line 11:   endif
Executing:   endif
line 12: 
Executing: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
Executing:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
Executing:   let c_lnum = line('.')
line 15:   let c_col = col('.')
Executing:   let c_col = col('.')
line 16:   let before = 0
Executing:   let before = 0
line 17: 
Executing: 
line 18:   let text = getline(c_lnum)
Executing:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
Executing:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
Executing:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
Executing:     let [c_before, c] = ['', '']
line 22:   else
Executing:   else
line 23:     let [c_before, c] = matches[1:2]
Executing:     let [c_before, c] = matches[1:2]
line 24:   endif
Executing:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
Executing:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
Executing:   let i = index(plist, c)
line 27:   if i < 0
Executing:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
Executing:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
Executing:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
Executing:       let before = strlen(c_before)
line 31:       let c = c_before
Executing:       let c = c_before
line 32:       let i = index(plist, c)
Executing:       let i = index(plist, c)
line 33:     endif
Executing:     endif
line 34:     if i < 0
Executing:     if i < 0
line 35:       " not found, nothing to do
Executing:       " not found, nothing to do
line 36:       return
Executing:       return
function <SNR>15_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"



Executing: q!
Writing viminfo file "/home/kangaroo/.viminfo"